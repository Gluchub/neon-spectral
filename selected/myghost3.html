<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NEON PHANTASM | A Cyber-Gothic Experience</title>
  
  <!-- Tailwind CSS -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  
  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css">
  
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- GSAP Animation Library -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.9.1/dist/gsap.min.js"></script>
  
  <style>
    :root {
      --neon-cyan: #00f3ff;
      --neon-purple: #c700f3;
      --neon-pink: #ff00c8;
      --neon-yellow: #ffd800;
      --neon-blue: #0066ff;
      --neon-green: #00ff88;
      --dark-bg: #0a0a1a;
      --darker-bg: #050510;
      --terminal-green: #00ff41;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background-color: var(--dark-bg);
      color: white;
      font-family: 'Rajdhani', sans-serif;
      overflow-x: hidden;
      position: relative;
    }
    
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: var(--dark-bg);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity 1s ease-in-out;
    }
    
    .loading-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 2rem;
      font-weight: 700;
      color: var(--neon-cyan);
      text-shadow: 0 0 10px var(--neon-cyan);
      margin-bottom: 2rem;
      letter-spacing: 0.5rem;
      animation: pulse 2s infinite;
    }
    
    .loading-bar {
      width: 60%;
      height: 2px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      position: relative;
      overflow: hidden;
    }
    
    .loading-progress {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--neon-purple), var(--neon-cyan));
      box-shadow: 0 0 15px var(--neon-cyan);
      transition: width 0.2s ease;
    }
    
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    
    h1, h2, h3, h4, h5 {
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
    }
    
    .neon-text {
      text-shadow: 
        0 0 5px var(--neon-cyan),
        0 0 10px var(--neon-cyan),
        0 0 20px var(--neon-cyan);
      color: var(--neon-cyan);
    }
    
    .neon-purple-text {
      text-shadow: 
        0 0 5px var(--neon-purple),
        0 0 10px var(--neon-purple),
        0 0 20px var(--neon-purple);
      color: var(--neon-purple);
    }
    
    .neon-pink-text {
      text-shadow: 
        0 0 5px var(--neon-pink),
        0 0 10px var(--neon-pink),
        0 0 20px var(--neon-pink);
      color: var(--neon-pink);
    }
    
    .header {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;
    }
    
    .glitch-title {
      font-size: 5rem;
      font-weight: 900;
      position: relative;
      z-index: 2;
      animation: glitch 5s infinite;
    }
    
    @keyframes glitch {
      0% { transform: translate(0); }
      1% { transform: translate(-3px, 2px); }
      2% { transform: translate(5px, -2px); }
      3% { transform: translate(0); }
      10% { transform: translate(0); }
      11% { transform: translate(-3px, -2px); }
      12% { transform: translate(5px, 2px); }
      13% { transform: translate(0); }
      100% { transform: translate(0); }
    }
    
    .subtitle {
      font-size: 1.5rem;
      margin-top: 1rem;
      font-weight: 500;
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .cyber-border {
      border: 1px solid var(--neon-cyan);
      position: relative;
    }
    
    .cyber-border::before {
      content: "";
      position: absolute;
      top: -5px;
      left: -5px;
      right: -5px;
      bottom: -5px;
      border: 1px solid var(--neon-cyan);
      opacity: 0.5;
    }
    
    .section {
      padding: 5rem 2rem;
      position: relative;
    }
    
    .section-title {
      font-size: 2.5rem;
      margin-bottom: 2rem;
      text-align: center;
      letter-spacing: 0.3rem;
    }
    
    .grid-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 2rem;
      max-width: 1300px;
      margin: 0 auto;
    }
    
    .card {
      position: relative;
      min-height: 350px;
      padding: 1.5rem;
      background: rgba(20, 20, 40, 0.6);
      border: 1px solid var(--neon-cyan);
      border-radius: 5px;
      overflow: hidden;
      transition: all 0.3s ease;
      transform-style: preserve-3d;
    }
    
    .card::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(0, 243, 255, 0.1) 0%, rgba(0, 0, 0, 0) 100%);
      z-index: 0;
    }
    
    .card:hover {
      transform: translateY(-10px) scale(1.02);
      box-shadow: 0 0 25px rgba(0, 243, 255, 0.4);
    }
    
    .card-content {
      position: relative;
      z-index: 1;
    }
    
    .card h3 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: var(--neon-cyan);
    }
    
    .card p {
      margin-bottom: 1rem;
      line-height: 1.6;
      font-size: 1.1rem;
    }
    
    .model-container {
      width: 100%;
      height: 200px;
      margin-bottom: 1rem;
      position: relative;
    }
    
    /* Particle canvas */
    #particles-js {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }
    
    /* WebGL canvas for holographic effects */
    #webgl-hologram {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      pointer-events: none;
    }
    
    /* HUD Elements */
    .hud-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }
    
    .hud-corner {
      position: absolute;
      width: 200px;
      height: 200px;
      opacity: 0.8;
    }
    
    .hud-top-left {
      top: 10px;
      left: 10px;
    }
    
    .hud-top-right {
      top: 10px;
      right: 10px;
      transform: scaleX(-1);
    }
    
    .hud-bottom-left {
      bottom: 10px;
      left: 10px;
      transform: scaleY(-1);
    }
    
    .hud-bottom-right {
      bottom: 10px;
      right: 10px;
      transform: scale(-1);
    }
    
    .hud-info {
      position: absolute;
      top: 90px;
      right: 30px;
      width: 250px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--neon-cyan);
      padding: 15px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      color: var(--neon-cyan);
      text-transform: uppercase;
    }
    
    .hud-info p {
      margin: 5px 0;
    }
    
    /* Scanner */
    .scanner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 300px;
      background: transparent;
      border-radius: 50%;
      border: 2px solid var(--neon-cyan);
      box-shadow: 0 0 20px var(--neon-cyan);
      opacity: 0;
      pointer-events: none;
      z-index: 200;
      transition: opacity 0.3s ease;
    }
    
    .scanner::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      border: 2px solid var(--neon-purple);
      animation: pulse-scanner 2s infinite;
    }
    
    @keyframes pulse-scanner {
      0% { transform: scale(0.8); opacity: 1; }
      100% { transform: scale(1.2); opacity: 0; }
    }
    
    /* Terminal */
    .terminal-container {
      position: fixed;
      bottom: -400px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 800px;
      height: 350px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid var(--terminal-green);
      padding: 10px;
      font-family: 'Courier New', monospace;
      z-index: 500;
      transition: bottom 0.5s ease;
      display: flex;
      flex-direction: column;
    }
    
    .terminal-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--terminal-green);
      padding-bottom: 5px;
    }
    
    .terminal-title {
      color: var(--terminal-green);
      font-weight: bold;
    }
    
    .terminal-close {
      cursor: pointer;
      color: var(--terminal-green);
    }
    
    .terminal-output {
      flex-grow: 1;
      overflow-y: auto;
      margin-bottom: 10px;
      color: var(--terminal-green);
    }
    
    .terminal-output p {
      margin: 5px 0;
    }
    
    .terminal-input-line {
      display: flex;
      align-items: center;
    }
    
    .terminal-prompt {
      color: var(--terminal-green);
      margin-right: 10px;
    }
    
    #terminal-input {
      background: transparent;
      border: none;
      color: var(--terminal-green);
      font-family: 'Courier New', monospace;
      font-size: 1rem;
      width: 100%;
      outline: none;
    }
    
    /* Navigation */
    .cyber-nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 300;
      background: rgba(10, 10, 26, 0.8);
      backdrop-filter: blur(10px);
    }
    
    .nav-logo {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--neon-cyan);
      text-decoration: none;
    }
    
    .nav-links {
      display: flex;
      gap: 1.5rem;
    }
    
    .nav-link {
      font-family: 'Orbitron', sans-serif;
      color: white;
      text-decoration: none;
      text-transform: uppercase;
      font-size: 0.9rem;
      letter-spacing: 1px;
      position: relative;
      transition: color 0.3s ease;
    }
    
    .nav-link:hover {
      color: var(--neon-cyan);
    }
    
    .nav-link::after {
      content: "";
      position: absolute;
      bottom: -5px;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--neon-cyan);
      transition: width 0.3s ease;
    }
    
    .nav-link:hover::after {
      width: 100%;
    }
    
    /* Spirit Encyclopedia */
    .spirit-entry {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 800px;
      height: 80vh;
      background: rgba(10, 10, 26, 0.9);
      border: 2px solid var(--neon-cyan);
      z-index: 600;
      padding: 2rem;
      overflow-y: auto;
    }
    
    .spirit-entry-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      border-bottom: 1px solid var(--neon-cyan);
      padding-bottom: 1rem;
    }
    
    .spirit-entry-title {
      font-size: 2rem;
      color: var(--neon-cyan);
    }
    
    .spirit-entry-close {
      cursor: pointer;
      font-size: 1.5rem;
      color: var(--neon-cyan);
    }
    
    .spirit-entry-content {
      line-height: 1.8;
    }
    
    .spirit-entry-image {
      width: 100%;
      height: 300px;
      margin: 1rem 0 2rem;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--neon-purple);
    }
    
    /* User Avatar System */
    .avatar-system {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 600px;
      background: rgba(10, 10, 26, 0.9);
      border: 2px solid var(--neon-pink);
      z-index: 600;
      padding: 2rem;
    }
    
    .avatar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--neon-pink);
      padding-bottom: 0.5rem;
    }
    
    .avatar-title {
      color: var(--neon-pink);
      font-size: 1.5rem;
    }
    
    .avatar-close {
      cursor: pointer;
      font-size: 1.5rem;
      color: var(--neon-pink);
    }
    
    .avatar-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .form-group label {
      font-family: 'Orbitron', sans-serif;
      color: white;
      text-transform: uppercase;
      font-size: 0.9rem;
    }
    
    .avatar-input {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--neon-pink);
      padding: 0.75rem;
      color: white;
      font-family: 'Rajdhani', sans-serif;
      outline: none;
    }
    
    .avatar-select {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--neon-pink);
      padding: 0.75rem;
      color: white;
      font-family: 'Rajdhani', sans-serif;
      outline: none;
    }
    
    .avatar-submit {
      background: var(--neon-pink);
      color: black;
      border: none;
      padding: 0.75rem;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      cursor: pointer;
      margin-top: 1rem;
      transition: all 0.3s ease;
    }
    
    .avatar-submit:hover {
      background: #ff40d3;
      box-shadow: 0 0 15px var(--neon-pink);
    }
    
    /* AR Integration */
    .ar-section {
      text-align: center;
      padding: 3rem 0;
    }
    
    .ar-container {
      max-width: 400px;
      margin: 0 auto;
      padding: 2rem;
      background: rgba(20, 20, 40, 0.6);
      border: 1px solid var(--neon-purple);
      border-radius: 5px;
    }
    
    .ar-title {
      color: var(--neon-purple);
      margin-bottom: 1rem;
    }
    
    .ar-desc {
      margin-bottom: 2rem;
      line-height: 1.6;
    }
    
    .ar-qr {
      width: 200px;
      height: 200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    /* ENHANCED Digital Ritual */
    .ritual-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(5, 5, 15, 0.95);
      z-index: 700;
      overflow: hidden;
    }

    /* Ritual background */
    .ritual-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(15, 15, 35, 0.6) 0%, rgba(5, 5, 15, 0.9) 70%);
      opacity: 0;
      transition: opacity 2s ease-in;
    }

    /* Ritual content wrapper */
    .ritual-content {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2;
    }
    
    .ritual-title {
      font-size: 2.5rem;
      margin-bottom: 1.5rem;
      opacity: 0;
      transform: translateY(-30px);
      transition: all 1.2s ease;
    }
    
    .ritual-instructions {
      font-family: 'Orbitron', sans-serif;
      color: white;
      text-align: center;
      margin-bottom: 2rem;
      font-size: 1.2rem;
      opacity: 0;
      transform: translateY(30px);
      transition: all 1s ease 0.2s;
    }

    /* Main magical circle */
    .ritual-circle-container {
      position: relative;
      width: 600px;
      height: 600px;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transform: scale(0.8);
      transition: all 1.5s cubic-bezier(0.25, 1, 0.5, 1) 0.5s;
    }
    
    /* Outer rotating rings */
    .ritual-outer-ring {
      position: absolute;
      border-radius: 50%;
      border: 2px solid var(--neon-pink);
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .ritual-outer-ring-2 {
      position: absolute;
      border-radius: 50%;
      border: 1px solid var(--neon-cyan);
      width: 92%;
      height: 92%;
      opacity: 0;
      transition: opacity 2s ease 0.3s;
    }
    
    .ritual-outer-ring-3 {
      position: absolute;
      border-radius: 50%;
      border: 1px solid var(--neon-purple);
      width: 85%;
      height: 85%;
      opacity: 0;
      transition: opacity 2s ease 0.6s;
    }

    /* Magic symbols around the circle */
    .ritual-symbols {
      position: absolute;
      width: 94%;
      height: 94%;
      border-radius: 50%;
      pointer-events: none;
    }

    .ritual-symbol {
      position: absolute;
      width: 40px;
      height: 40px;
      transform-origin: center;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .ritual-symbol svg {
      width: 100%;
      height: 100%;
      fill: none;
      stroke: var(--neon-cyan);
      stroke-width: 1;
    }

    /* Energy connecting lines */
    .ritual-energy-lines {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .energy-line {
      position: absolute;
      top: 50%;
      left: 50%;
      height: 2px;
      transform-origin: left center;
      background: linear-gradient(90deg, rgba(255,0,200,0.1), rgba(255,0,200,1));
      opacity: 0;
      box-shadow: 0 0 10px var(--neon-pink);
    }

    /* Well container */
    .ritual-well {
      position: absolute;
      width: 280px;
      height: 280px;
      border-radius: 50%;
      background: radial-gradient(circle at center, rgba(10,10,30,0.6) 0%, rgba(5,5,20,0.95) 90%);
      overflow: hidden;
      transition: all 0.5s ease;
      box-shadow: 
        0 0 20px rgba(0, 243, 255, 0.3),
        inset 0 0 30px rgba(0, 243, 255, 0.2);
    }

    .ritual-well::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      border: 2px solid rgba(0, 243, 255, 0.5);
      box-shadow: inset 0 0 30px rgba(0, 243, 255, 0.3);
      z-index: 1;
      opacity: 0;
      transition: opacity 1s ease;
    }

    /* Magic liquid in the well */
    .ritual-liquid {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0;
      background: linear-gradient(0deg, rgba(199,0,243,0.4), rgba(0,243,255,0.1));
      transition: height 3s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 1;
    }

    .liquid-surface {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 15px;
      background: rgba(0,243,255,0.3);
      transform: translateY(-50%);
      filter: blur(1px);
      box-shadow: 0 0 15px var(--neon-cyan);
      z-index: 2;
    }

    /* Magic portal that appears when ritual completes */
    .ritual-portal {
      position: absolute;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: radial-gradient(circle at center, rgba(255,0,200,0.8) 0%, rgba(199,0,243,0.4) 60%, transparent 100%);
      box-shadow: 0 0 30px var(--neon-pink), 0 0 60px var(--neon-purple);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
      opacity: 0;
      z-index: 2;
    }

    /* Spirit manifestation */
    .ritual-spirit {
      position: absolute;
      width: 0;
      height: 0;
      background: radial-gradient(circle at center, white 0%, transparent 70%);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
      z-index: 3;
    }

    /* Interactive node elements */
    .ritual-node-container {
      position: absolute;
      width: 400px;
      height: 400px;
      border-radius: 50%;
      pointer-events: none;
    }

    .ritual-node {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(10, 10, 30, 0.6);
      border: 2px solid rgba(0, 243, 255, 0.6);
      box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
      cursor: pointer;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
      pointer-events: auto;
    }

    .ritual-node::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 70%;
      height: 70%;
      border-radius: 50%;
      background: rgba(0, 243, 255, 0.2);
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
    }

    .ritual-node:hover {
      border-color: rgba(0, 243, 255, 1);
      box-shadow: 0 0 20px rgba(0, 243, 255, 0.7);
      transform: translate(-50%, -50%) scale(1.1);
    }

    .ritual-node.active {
      background: rgba(0, 243, 255, 0.8);
      border-color: white;
      box-shadow: 
        0 0 20px rgba(0, 243, 255, 0.7),
        0 0 40px rgba(0, 243, 255, 0.4);
    }

    .ritual-node.active::before {
      background: rgba(255, 255, 255, 0.8);
    }

    /* Floating runes and particles */
    .ritual-particles {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .ritual-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: var(--neon-cyan);
      border-radius: 50%;
      box-shadow: 0 0 15px var(--neon-cyan);
      opacity: 0;
    }

    .ritual-rune {
      position: absolute;
      font-family: 'Orbitron', sans-serif;
      color: var(--neon-cyan);
      font-size: 1.2rem;
      text-shadow: 0 0 10px var(--neon-cyan);
      opacity: 0;
      transform: scale(0);
    }

    /* Magic effects for completed ritual */
    .ritual-completion-fx {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
    }

    .ritual-rays {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 600px;
      height: 600px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      opacity: 0;
    }

    .ritual-ray {
      position: absolute;
      top: 50%;
      left: 50%;
      height: 2px;
      background: var(--neon-pink);
      transform-origin: left center;
      opacity: 0.7;
      box-shadow: 0 0 10px var(--neon-pink);
    }

    /* Status message */
    .ritual-message {
      margin-top: 2rem;
      font-family: 'Orbitron', sans-serif;
      color: white;
      font-size: 1.5rem;
      text-align: center;
      min-height: 2rem;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.8s ease 1s;
    }

    /* Close button */
    .ritual-close {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 1.5rem;
      color: var(--neon-cyan);
      cursor: pointer;
      z-index: 10;
      opacity: 0;
      transition: all 0.3s ease 1.5s;
    }

    .ritual-close:hover {
      transform: scale(1.1);
      text-shadow: 0 0 15px var(--neon-cyan);
    }

    /* Extra decorative elements */
    .corner-decoration {
      position: absolute;
      width: 150px;
      height: 150px;
      opacity: 0;
      transition: opacity 1s ease 1.2s;
    }

    .corner-top-left {
      top: 20px;
      left: 20px;
    }

    .corner-top-right {
      top: 20px;
      right: 20px;
      transform: scaleX(-1);
    }

    .corner-bottom-left {
      bottom: 20px;
      left: 20px;
      transform: scaleY(-1);
    }

    .corner-bottom-right {
      bottom: 20px;
      right: 20px;
      transform: scale(-1);
    }

    /* Animations */
    @keyframes rotateClockwise {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes rotateCounterClockwise {
      from { transform: rotate(0deg); }
      to { transform: rotate(-360deg); }
    }

    @keyframes floatParticle {
      0% { transform: translate(0, 0); opacity: 0; }
      20% { opacity: 0.8; }
      80% { opacity: 0.8; }
      100% { transform: translate(var(--tx), var(--ty)); opacity: 0; }
    }

    @keyframes pulseGlow {
      0% { opacity: 0.5; box-shadow: 0 0 10px var(--neon-cyan); }
      50% { opacity: 1; box-shadow: 0 0 25px var(--neon-cyan); }
      100% { opacity: 0.5; box-shadow: 0 0 10px var(--neon-cyan); }
    }

    @keyframes floatRune {
      0% { transform: translate(0, 0) scale(0); opacity: 0; }
      20% { transform: translate(0, 0) scale(1); opacity: 0.8; }
      80% { transform: translate(var(--tx), var(--ty)) scale(1); opacity: 0.8; }
      100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }

    @keyframes liquidRipple {
      0% { transform: scale(1); opacity: 0.7; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    @keyframes portalPulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    @keyframes summon-pulse {
      0% { transform: scale(0.1); opacity: 0.8; }
      50% { transform: scale(1.5); opacity: 0.5; }
      100% { transform: scale(3); opacity: 0; }
    }

    @keyframes spiritManifest {
      0% { transform: translate(-50%, -50%) scale(0.1); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(2); opacity: 0.7; }
      90% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
      100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0; }
    }

    /* Footer */
    .footer {
      background: rgba(0, 0, 0, 0.6);
      padding: 2rem;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    
    .footer-content {
      max-width: 800px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    
    .footer::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--neon-cyan), transparent);
    }
    
    .footer-text {
      margin-bottom: 1rem;
    }
    
    .social-links {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }
    
    .social-icon {
      color: white;
      font-size: 1.5rem;
      transition: color 0.3s ease;
    }
    
    .social-icon:hover {
      color: var(--neon-cyan);
    }
    
    /* Responsive styles */
    @media (max-width: 768px) {
      .glitch-title {
        font-size: 3rem;
      }
      
      .section-title {
        font-size: 2rem;
      }
      
      .hud-info {
        width: 200px;
        font-size: 0.8rem;
      }
      
      .terminal-container {
        width: 95%;
      }

      .ritual-circle-container {
        width: 350px;
        height: 350px;
      }

      .ritual-well {
        width: 200px;
        height: 200px;
      }

      .ritual-node-container {
        width: 300px;
        height: 300px;
      }

      .ritual-node {
        width: 30px;
        height: 30px;
      }

      .ritual-rays {
        width: 400px;
        height: 400px;
      }

      .corner-decoration {
        width: 100px;
        height: 100px;
      }
    }

    @media (max-width: 480px) {
      .ritual-circle-container {
        width: 300px;
        height: 300px;
      }

      .ritual-well {
        width: 160px;
        height: 160px;
      }

      .ritual-node-container {
        width: 240px;
        height: 240px;
      }

      .ritual-node {
        width: 25px;
        height: 25px;
      }

      .ritual-title {
        font-size: 2rem;
      }

      .ritual-instructions {
        font-size: 1rem;
      }

      .ritual-message {
        font-size: 1.2rem;
      }
    }
    .home-btn {
    position: fixed;
    top: 80px;
    left: 20px;
    z-index: 1000;
    overflow: visible;
    padding: 10px 25px;
    background-color: rgba(10, 10, 18, 0.7);
    transition: all 0.3s ease;
}

.home-btn:hover {
    transform: translateY(-3px);
}

.home-btn .btn-text {
    position: relative;
    z-index: 2;
}

.btn-glow {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 245, 212, 0.1);
    z-index: 1;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.home-btn:hover .btn-glow {
    opacity: 1;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(0, 245, 212, 0.4); }
    70% { box-shadow: 0 0 0 10px rgba(0, 245, 212, 0); }
    100% { box-shadow: 0 0 0 0 rgba(0, 245, 212, 0); }
}
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loading-screen">
    <div class="loading-text">INITIALIZING NEON PHANTASM</div>
    <div class="loading-bar">
      <div class="loading-progress" id="loading-progress"></div>
    </div>
  </div>
  
  <!-- WebGL Background -->
  <canvas style="display: none;" id="webgl-hologram"></canvas>
  
  <!-- Particle System -->
  <div id="particles-js"></div>
  
  <!-- HUD Elements -->
  <div class="hud-container">
    <svg class="hud-corner hud-top-left" viewBox="0 0 100 100">
      <path d="M0,0 L40,0 L40,5 L5,5 L5,40 L0,40 Z" fill="none" stroke="var(--neon-cyan)" stroke-width="1"></path>
    </svg>
    <svg class="hud-corner hud-top-right" viewBox="0 0 100 100">
      <path d="M0,0 L40,0 L40,5 L5,5 L5,40 L0,40 Z" fill="none" stroke="var(--neon-cyan)" stroke-width="1"></path>
    </svg>
    <svg class="hud-corner hud-bottom-left" viewBox="0 0 100 100">
      <path d="M0,0 L40,0 L40,5 L5,5 L5,40 L0,40 Z" fill="none" stroke="var(--neon-cyan)" stroke-width="1"></path>
    </svg>
    <svg class="hud-corner hud-bottom-right" viewBox="0 0 100 100">
      <path d="M0,0 L40,0 L40,5 L5,5 L5,40 L0,40 Z" fill="none" stroke="var(--neon-cyan)" stroke-width="1"></path>
    </svg>
    
    <div class="hud-info">
      <p>SYSTEM: <span class="neon-text">ONLINE</span></p>
      <p>SPIRITS: <span id="spirit-count" class="neon-purple-text">0/6</span></p>
      <p>CONNECTION: <span class="neon-text">ACTIVE</span></p>
    </div>
    
    <div class="scanner" id="spirit-scanner"></div>
  </div>
  
  <!-- Navigation -->
  <nav class="cyber-nav">
    <a href="#" class="nav-logo">NEON PHANTASM</a>
    <div class="nav-links">
      <a href="#digital-shrine" class="nav-link">Digital Shrine</a>
      <a href="#spirit-database" class="nav-link">Spirit Database</a>
      <a href="#neon-nexus" class="nav-link">Neon Nexus</a>
      <a href="#" class="nav-link" id="terminal-trigger">Terminal</a>
      <a href="#" class="nav-link" id="avatar-trigger">Profile</a>
    </div>
  </nav>

  <button class="btn home-btn" onclick="window.location.href='/'">
    <span class="btn-text glitch" data-text="HOME">HOME</span>
    <div class="btn-glow"></div>
  </button>
  
  <!-- Header Section -->
  <header class="header" id="home">
    <h1 class="glitch-title neon-text">NEON PHANTASM</h1>
    <p class="subtitle">A Cyber-Gothic Experience</p>
    <button id="enter-button" class="cyber-border px-8 py-3 mt-8 text-lg uppercase font-orbitron tracking-wider neon-text bg-transparent hover:bg-[rgba(0,243,255,0.1)] transition-all">Enter The Nexus</button>
  </header>
  
  <!-- Digital Shrine Section -->
  <section class="section" id="digital-shrine">
    <h2 class="section-title neon-text">Digital Shrine</h2>
    <p class="text-center text-xl mb-8">Explore holographic projects inspired by the spiritual realm.</p>
    
    <div class="grid-container">
      <div class="card" data-project="spirit-nexus">
        <div class="card-content">
          <div class="model-container" id="model-spirit-nexus"></div>
          <h3 class="neon-text">Spirit Nexus</h3>
          <p>A digital bridge between the mortal and spirit realms. This advanced interface combines ancient rituals with neural network technology to establish connections between dimensions.</p>
          <button class="cyber-border px-4 py-2 w-full neon-text bg-transparent hover:bg-[rgba(0,243,255,0.1)] transition-all">Explore</button>
        </div>
      </div>
      
      <div class="card" data-project="neon-torii">
        <div class="card-content">
          <div class="model-container" id="model-neon-torii"></div>
          <h3 class="neon-text">Neon Torii</h3>
          <p>Virtual gateways connecting the cyber-physical. These digital structures act as pathways for data spirits, allowing them to manifest across networks while preserving traditional sacred boundaries.</p>
          <button class="cyber-border px-4 py-2 w-full neon-text bg-transparent hover:bg-[rgba(0,243,255,0.1)] transition-all">Explore</button>
        </div>
      </div>
      
      <div class="card" data-project="ethereal-interface">
        <div class="card-content">
          <div class="model-container" id="model-ethereal-interface"></div>
          <h3 class="neon-text">Ethereal Interface</h3>
          <p>Holographic UI systems for spiritual navigation. This revolutionary interface translates ethereal energy signatures into tangible interactive elements, allowing direct communication with spiritual entities.</p>
          <button class="cyber-border px-4 py-2 w-full neon-text bg-transparent hover:bg-[rgba(0,243,255,0.1)] transition-all">Explore</button>
        </div>
      </div>
      
      <div class="card" data-project="phantom-protocol">
        <div class="card-content">
          <div class="model-container" id="model-phantom-protocol"></div>
          <h3 class="neon-text">Phantom Protocol</h3>
          <p>Containment systems for digital yokai entities. This security framework prevents malevolent digital spirits from causing system corruption while allowing benevolent entities to optimize network performance.</p>
          <button class="cyber-border px-4 py-2 w-full neon-text bg-transparent hover:bg-[rgba(0,243,255,0.1)] transition-all">Explore</button>
        </div>
      </div>
    </div>
  </section>
  
  <!-- Spirit Database Section -->
  <section class="section" id="spirit-database">
    <h2 class="section-title neon-purple-text">Spirit Database</h2>
    <p class="text-center text-xl mb-8">A collection of yokai-inspired digital entities.</p>
    
    <div class="grid-container">
      <div class="card" data-spirit="cyber-kappa">
        <div class="card-content">
          <div class="model-container" id="model-cyber-kappa"></div>
          <h3 class="neon-purple-text">Cyber Kappa</h3>
          <p>Digital water spirits that inhabit data streams. Known for their mischievous interference with network traffic but can be appeased by offering computing resources.</p>
          <button class="cyber-border px-4 py-2 w-full neon-purple-text bg-transparent hover:bg-[rgba(199,0,243,0.1)] transition-all spirit-info-btn" data-spirit="cyber-kappa">View Database Entry</button>
        </div>
      </div>
      
      <div class="card" data-spirit="neon-tengu">
        <div class="card-content">
          <div class="model-container" id="model-neon-tengu"></div>
          <h3 class="neon-purple-text">Neon Tengu</h3>
          <p>Proud digital guardians of encrypted information. These winged entities patrol firewalls and punish those who attempt unauthorized access to protected data.</p>
          <button class="cyber-border px-4 py-2 w-full neon-purple-text bg-transparent hover:bg-[rgba(199,0,243,0.1)] transition-all spirit-info-btn" data-spirit="neon-tengu">View Database Entry</button>
        </div>
      </div>
      
      <div class="card" data-spirit="digital-yurei">
        <div class="card-content">
          <div class="model-container" id="model-digital-yurei"></div>
          <h3 class="neon-purple-text">Digital Yūrei</h3>
          <p>Remnants of deleted data that continue to manifest in systems. These ghost-like entities cling to fragments of their original files, causing echoes of past information to appear.</p>
          <button class="cyber-border px-4 py-2 w-full neon-purple-text bg-transparent hover:bg-[rgba(199,0,243,0.1)] transition-all spirit-info-btn" data-spirit="digital-yurei">View Database Entry</button>
        </div>
      </div>
      
      <div class="card" data-spirit="electric-kitsune">
        <div class="card-content">
          <div class="model-container" id="model-electric-kitsune"></div>
          <h3 class="neon-purple-text">Electric Kitsune</h3>
          <p>Fox-like beings that manipulate electrical currents. Known for their ability to shape-shift network packets and create illusory connections to deceive system administrators.</p>
          <button class="cyber-border px-4 py-2 w-full neon-purple-text bg-transparent hover:bg-[rgba(199,0,243,0.1)] transition-all spirit-info-btn" data-spirit="electric-kitsune">View Database Entry</button>
        </div>
      </div>
      
      <div class="card" data-spirit="glitch-oni">
        <div class="card-content">
          <div class="model-container" id="model-glitch-oni"></div>
          <h3 class="neon-purple-text">Glitch Oni</h3>
          <p>Malevolent entities born from system errors. These demons manifest during critical system failures and feed off computational chaos, expanding their presence during crashes.</p>
          <button class="cyber-border px-4 py-2 w-full neon-purple-text bg-transparent hover:bg-[rgba(199,0,243,0.1)] transition-all spirit-info-btn" data-spirit="glitch-oni">View Database Entry</button>
        </div>
      </div>
      
      <div class="card" data-spirit="hologram-tanuki">
        <div class="card-content">
          <div class="model-container" id="model-hologram-tanuki"></div>
          <h3 class="neon-purple-text">Hologram Tanuki</h3>
          <p>Trickster entities that manipulate AR/VR experiences. These playful spirits can alter holographic projections, creating misleading but often harmlessly amusing visual data.</p>
          <button class="cyber-border px-4 py-2 w-full neon-purple-text bg-transparent hover:bg-[rgba(199,0,243,0.1)] transition-all spirit-info-btn" data-spirit="hologram-tanuki">View Database Entry</button>
        </div>
      </div>
    </div>
  </section>
  
  <!-- Neon Nexus Section -->
  <section class="section" id="neon-nexus">
    <h2 class="section-title neon-pink-text">Neon Nexus</h2>
    <p class="text-center text-xl mb-8">Connect with the digital spirit realm.</p>
    
    <div class="grid-container">
      <div class="card">
        <div class="card-content">
          <h3 class="neon-pink-text">Digital Ritual</h3>
          <p>Participate in a cyber-spiritual ceremony to establish connection with yokai entities. Complete the ritual pattern to summon a digital guardian.</p>
          <button id="ritual-trigger" class="cyber-border px-4 py-2 w-full neon-pink-text bg-transparent hover:bg-[rgba(255,0,200,0.1)] transition-all">Begin Ritual</button>
        </div>
      </div>
      
      
    </div>
  </section>
  
  <!-- Footer -->
  <footer class="footer">
    <div class="footer-content">
      <p class="footer-text">© 2023 NEON PHANTASM | A Cyber-Gothic Experience</p>
      <div class="social-links">
        <a href="#" class="social-icon"><i class="fab fa-github"></i></a>
        <a href="#" class="social-icon"><i class="fab fa-twitter"></i></a>
        <a href="#" class="social-icon"><i class="fab fa-instagram"></i></a>
        <a href="#" class="social-icon"><i class="fab fa-discord"></i></a>
      </div>
      <p class="text-sm opacity-70">Crafted with digital ectoplasm and quantum entanglement</p>
    </div>
  </footer>
  
  <!-- Terminal Interface -->
  <div class="terminal-container" id="terminal">
    <div class="terminal-header">
      <div class="terminal-title">NEON PHANTASM TERMINAL v1.0.3</div>
      <div class="terminal-close" id="terminal-close">✕</div>
    </div>
    <div class="terminal-output" id="terminal-output">
      <p>Welcome to the NEON PHANTASM terminal system.</p>
      <p>Type 'help' for available commands.</p>
    </div>
    <div class="terminal-input-line">
      <span class="terminal-prompt">></span>
      <input type="text" id="terminal-input" autocomplete="off">
    </div>
  </div>
  
  <!-- Spirit Encyclopedia Entries -->
  <div class="spirit-entry" id="spirit-cyber-kappa">
    <div class="spirit-entry-header">
      <h3 class="spirit-entry-title">Cyber Kappa</h3>
      <div class="spirit-entry-close" data-spirit="cyber-kappa">✕</div>
    </div>
    <div class="spirit-entry-content">
      <div class="spirit-entry-image" id="render-cyber-kappa"></div>
      <h4 class="text-xl neon-purple-text mb-2">Classification: Aquatic Network Entity</h4>
      <p class="mb-4">Cyber Kappas are digital water spirits that have evolved to inhabit data streams and network flows. Originally manifesting in Japanese networks, these entities have now spread globally across high-bandwidth connections.</p>
      
      <h4 class="text-xl neon-purple-text mb-2">Behavior Patterns</h4>
      <p class="mb-4">These mischievous spirits are known for temporarily redirecting packets and causing minor network delays. They particularly favor media streaming services where they can "drink" from the data flow. When angered, they can cause buffering issues and temporary connection drops.</p>
      
      <h4 class="text-xl neon-purple-text mb-2">Digital Habitat</h4>
      <p class="mb-4">Cyber Kappas primarily dwell in high-bandwidth connections, especially underwater fiber optic cables. They gather around major data centers and internet exchange points, with notable populations near coastal server farms.</p>
      
      <h4 class="text-xl neon-purple-text mb-2">Appeasement Protocol</h4>
      <p class="mb-4">To maintain good relations with Cyber Kappas, system administrators often allocate small amounts of unused bandwidth specifically for these entities. Some network engineers leave "cucumber data" - small benign encrypted packets that Cyber Kappas find particularly delicious.</p>
      
      <h4 class="text-xl neon-purple-text mb-2">Historical Manifestations</h4>
      <p>The first documented Cyber Kappa incident occurred during the transpacific cable expansion of 2008, when several data centers in Tokyo experienced unexplained traffic patterns that resembled traditional kappa behavior. Since then, specialized monitoring systems have been developed to track and coexist with these digital entities.</p>
    </div>
  </div>
  
  <!-- More Spirit Entries Would Be Added Here -->
  
  <!-- User Avatar System -->
  <div class="avatar-system" id="avatar-system">
    <div class="avatar-header">
      <h3 class="avatar-title">Digital Spirit Profile</h3>
      <div class="avatar-close" id="avatar-close">✕</div>
    </div>
    <form class="avatar-form" id="avatar-form">
      <div class="form-group">
        <label for="avatar-name">Spirit Name</label>
        <input type="text" id="avatar-name" class="avatar-input" placeholder="Enter your digital spirit name">
      </div>
      <div class="form-group">
        <label for="avatar-type">Spirit Type</label>
        <select id="avatar-type" class="avatar-select">
          <option value="kitsune">Electric Kitsune</option>
          <option value="tengu">Neon Tengu</option>
          <option value="yurei">Digital Yūrei</option>
          <option value="kappa">Cyber Kappa</option>
          <option value="oni">Glitch Oni</option>
          <option value="tanuki">Hologram Tanuki</option>
        </select>
      </div>
      <div class="form-group">
        <label for="avatar-affinity">Digital Affinity</label>
        <select id="avatar-affinity" class="avatar-select">
          <option value="data">Data Streams</option>
          <option value="security">Network Security</option>
          <option value="storage">Memory Storage</option>
          <option value="encryption">Encryption</option>
          <option value="processing">Quantum Processing</option>
        </select>
      </div>
      <button type="submit" class="avatar-submit">Create Digital Avatar</button>
    </form>
  </div>
  
  <!-- ENHANCED Digital Ritual Interface -->
  <div class="ritual-container" id="ritual-container">
    <div class="ritual-bg"></div>
    
    <div class="ritual-content">
      <!-- Corner decorations -->
      <svg class="corner-decoration corner-top-left" viewBox="0 0 100 100">
        <path d="M0,0 L60,0 L60,10 L10,10 L10,60 L0,60 Z" fill="none" stroke="var(--neon-pink)" stroke-width="1.5"></path>
      </svg>
      <svg class="corner-decoration corner-top-right" viewBox="0 0 100 100">
        <path d="M0,0 L60,0 L60,10 L10,10 L10,60 L0,60 Z" fill="none" stroke="var(--neon-pink)" stroke-width="1.5"></path>
      </svg>
      <svg class="corner-decoration corner-bottom-left" viewBox="0 0 100 100">
        <path d="M0,0 L60,0 L60,10 L10,10 L10,60 L0,60 Z" fill="none" stroke="var(--neon-pink)" stroke-width="1.5"></path>
      </svg>
      <svg class="corner-decoration corner-bottom-right" viewBox="0 0 100 100">
        <path d="M0,0 L60,0 L60,10 L10,10 L10,60 L0,60 Z" fill="none" stroke="var(--neon-pink)" stroke-width="1.5"></path>
      </svg>
      
      <h3 class="ritual-title neon-pink-text">Digital Spirit Summoning</h3>
      <div class="ritual-instructions">Activate the nodes in the correct sequence to complete the ritual</div>
      
      <div class="ritual-circle-container">
        <!-- Rotating outer rings -->
        <div class="ritual-outer-ring"></div>
        <div class="ritual-outer-ring-2"></div>
        <div class="ritual-outer-ring-3"></div>
        
        <!-- Magic Symbols -->
        <div class="ritual-symbols">
          <!-- Will be populated by JS -->
        </div>
        
        <!-- Energy connecting lines -->
        <div class="ritual-energy-lines">
          <!-- Will be populated by JS when nodes are activated -->
        </div>
        
        <!-- Magic well -->
        <div class="ritual-well">
          <div class="ritual-liquid">
            <div class="liquid-surface"></div>
          </div>
          <div class="ritual-portal"></div>
          <div class="ritual-spirit"></div>
        </div>
        
        <!-- Interactive nodes -->
        <div class="ritual-node-container">
          <!-- Will be populated by JS -->
        </div>
        
        <!-- Magic particles -->
        <div class="ritual-particles">
          <!-- Will be populated by JS -->
        </div>
        
        <!-- Completion effects -->
        <div class="ritual-completion-fx"></div>
        
        <!-- Light rays -->
        <div class="ritual-rays">
          <!-- Will be populated by JS -->
        </div>
      </div>
      
      <p id="ritual-message" class="ritual-message neon-text">Awaiting activation sequence...</p>
    </div>
    
    <div class="ritual-close" id="ritual-close">✕</div>
  </div>
  
  <!-- Import Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js"></script>
  
  <script>
    // Loading Screen
    document.addEventListener('DOMContentLoaded', () => {
      const loadingProgress = document.getElementById('loading-progress');
      const loadingScreen = document.getElementById('loading-screen');
      let progress = 0;
      
      const loadingInterval = setInterval(() => {
        progress += Math.random() * 10;
        if (progress >= 100) {
          progress = 100;
          clearInterval(loadingInterval);
          
          setTimeout(() => {
            loadingScreen.style.opacity = 0;
            setTimeout(() => {
              loadingScreen.style.display = 'none';
              initializeWebGL();
              initializeParticles();
              initializeHolograms();
              initializeSoundscape();
              initializeRitualElements();
            }, 1000);
          }, 500);
        }
        
        loadingProgress.style.width = `${progress}%`;
      }, 200);
      
      // Initialize event listeners
      initEventListeners();
    });
    
    // Initialize Event Listeners
    function initEventListeners() {
      // Terminal triggers
      document.getElementById('terminal-trigger').addEventListener('click', (e) => {
        e.preventDefault();
        toggleTerminal();
      });
      
      document.getElementById('terminal-close').addEventListener('click', () => {
        toggleTerminal(false);
      });
      
      document.getElementById('terminal-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          processTerminalCommand(e.target.value);
          e.target.value = '';
        }
      });
      
      // Avatar system
      document.getElementById('avatar-trigger').addEventListener('click', (e) => {
        e.preventDefault();
        toggleAvatarSystem();
      });
      
      document.getElementById('avatar-close').addEventListener('click', () => {
        toggleAvatarSystem(false);
      });
      
      document.getElementById('avatar-form').addEventListener('submit', (e) => {
        e.preventDefault();
        createUserAvatar();
      });
      
      // Spirit info buttons
      const spiritButtons = document.querySelectorAll('.spirit-info-btn');
      spiritButtons.forEach(button => {
        button.addEventListener('click', () => {
          const spirit = button.getAttribute('data-spirit');
          showSpiritEntry(spirit);
        });
      });
      
      // Spirit entry close buttons
      const spiritCloseButtons = document.querySelectorAll('.spirit-entry-close');
      spiritCloseButtons.forEach(button => {
        button.addEventListener('click', () => {
          const spirit = button.getAttribute('data-spirit');
          hideSpiritEntry(spirit);
        });
      });
      
      // Digital ritual
      document.getElementById('ritual-trigger').addEventListener('click', (e) => {
        e.preventDefault();
        toggleRitual(true);
      });
      
      document.getElementById('ritual-close').addEventListener('click', () => {
        toggleRitual(false);
      });
      
      // Enter button animation
      document.getElementById('enter-button').addEventListener('click', () => {
        playSound('interface');
        document.getElementById('digital-shrine').scrollIntoView({ behavior: 'smooth' });
      });
    }
    
    // Initialize Ritual Elements
    function initializeRitualElements() {
      const symbolsContainer = document.querySelector('.ritual-symbols');
      const nodeContainer = document.querySelector('.ritual-node-container');
      const raysContainer = document.querySelector('.ritual-rays');
      
      // Create magical symbols around the circle
      const symbolsCount = 12;
      const symbolsArray = ['⦿', '⧗', '⧫', '⧉', '⌬', '☱', '☲', '☵', '☶', '☯', '⚶', '⚱'];
      
      for (let i = 0; i < symbolsCount; i++) {
        const angle = (i / symbolsCount) * Math.PI * 2;
        const radius = 47; // % of container
        
        const symbol = document.createElement('div');
        symbol.className = 'ritual-symbol';
        symbol.innerHTML = `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
          <text x="20" y="25" text-anchor="middle" font-family="monospace" font-size="20" stroke="var(--neon-cyan)" fill="none">${symbolsArray[i % symbolsArray.length]}</text>
        </svg>`;
        
        const x = 50 + radius * Math.cos(angle);
        const y = 50 + radius * Math.sin(angle);
        symbol.style.left = `${x}%`;
        symbol.style.top = `${y}%`;
        symbol.style.transform = `translate(-50%, -50%) rotate(${angle + Math.PI/2}rad)`;
        
        symbolsContainer.appendChild(symbol);
      }
      
      // Create ritual nodes
      const nodeCount = 8;
      for (let i = 0; i < nodeCount; i++) {
        const angle = (i / nodeCount) * Math.PI * 2;
        const radius = 45; // % of container
        
        const node = document.createElement('div');
        node.className = 'ritual-node';
        node.setAttribute('data-node', i + 1);
        
        const x = 50 + radius * Math.cos(angle);
        const y = 50 + radius * Math.sin(angle);
        node.style.left = `${x}%`;
        node.style.top = `${y}%`;
        
        node.addEventListener('click', () => {
          activateRitualNode(node);
        });
        
        nodeContainer.appendChild(node);
      }
      
      // Create light rays for the completion effect
      for (let i = 0; i < 24; i++) {
        const angle = (i / 24) * Math.PI * 2;
        const ray = document.createElement('div');
        ray.className = 'ritual-ray';
        
        ray.style.width = `${300 + Math.random() * 100}px`;
        ray.style.transform = `rotate(${angle}rad)`;
        
        raysContainer.appendChild(ray);
      }
    }
    
    // WebGL Background
    function initializeWebGL() {
      const canvas = document.getElementById('webgl-hologram');
      const renderer = new THREE.WebGLRenderer({
        canvas,
        alpha: true,
        antialias: true
      });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Create grid
      const gridSize = 50;
      const gridDivisions = 50;
      const gridColor1 = new THREE.Color(0x00f3ff);
      const gridColor2 = new THREE.Color(0xc700f3);
      
      const grid = new THREE.GridHelper(gridSize, gridDivisions, gridColor1, gridColor2);
      grid.rotation.x = Math.PI / 2;
      grid.position.z = -10;
      scene.add(grid);
      
      // Create animated lines
      const lines = [];
      for (let i = 0; i < 20; i++) {
        const geometry = new THREE.BufferGeometry();
        const points = [];
        
        const length = Math.random() * 5 + 3;
        const x = Math.random() * 20 - 10;
        const y = Math.random() * 20 - 10;
        const z = Math.random() * -20 - 5;
        
        points.push(new THREE.Vector3(x, y, z));
        points.push(new THREE.Vector3(x, y, z - length));
        
        geometry.setFromPoints(points);
        
        const material = new THREE.LineBasicMaterial({
          color: Math.random() > 0.5 ? 0x00f3ff : 0xc700f3,
          transparent: true,
          opacity: Math.random() * 0.5 + 0.5
        });
        
        const line = new THREE.Line(geometry, material);
        line.userData = {
          speed: Math.random() * 0.1 + 0.05,
          maxZ: 5
        };
        
        scene.add(line);
        lines.push(line);
      }
      
      // Animation
      function animate() {
        requestAnimationFrame(animate);
        
        // Animate grid
        grid.rotation.z += 0.001;
        grid.position.y = Math.sin(Date.now() * 0.0005) * 0.5;
        
        // Animate lines
        lines.forEach(line => {
          line.position.z += line.userData.speed;
          
          if (line.position.z > line.userData.maxZ) {
            line.position.z = -25;
          }
        });
        
        renderer.render(scene, camera);
      }
      
      animate();
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
    
    // Particle System
    function initializeParticles() {
      particlesJS('particles-js', {
        "particles": {
          "number": {
            "value": 80,
            "density": {
              "enable": true,
              "value_area": 800
            }
          },
          "color": {
            "value": ["#00f3ff", "#c700f3", "#ff00c8"]
          },
          "shape": {
            "type": "circle"
          },
          "opacity": {
            "value": 0.5,
            "random": true,
            "anim": {
              "enable": true,
              "speed": 1,
              "opacity_min": 0.1,
              "sync": false
            }
          },
          "size": {
            "value": 3,
            "random": true,
            "anim": {
              "enable": true,
              "speed": 2,
              "size_min": 0.1,
              "sync": false
            }
          },
          "line_linked": {
            "enable": true,
            "distance": 150,
            "color": "#00f3ff",
            "opacity": 0.2,
            "width": 1
          },
          "move": {
            "enable": true,
            "speed": 1,
            "direction": "none",
            "random": true,
            "straight": false,
            "out_mode": "out",
            "bounce": false,
            "attract": {
              "enable": true,
              "rotateX": 600,
              "rotateY": 1200
            }
          }
        },
        "interactivity": {
          "detect_on": "canvas",
          "events": {
            "onhover": {
              "enable": true,
              "mode": "grab"
            },
            "onclick": {
              "enable": true,
              "mode": "push"
            },
            "resize": true
          },
          "modes": {
            "grab": {
              "distance": 140,
              "line_linked": {
                "opacity": 0.5
              }
            },
            "push": {
              "particles_nb": 4
            }
          }
        },
        "retina_detect": true
      });
    }
    
    // 3D Holographic Models
    function initializeHolograms() {
      const modelContainers = document.querySelectorAll('.model-container');
      
      modelContainers.forEach(container => {
        const id = container.id;
        const renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true
        });
        
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.z = 5;
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0x00f3ff, 1);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);
        
        // Create holographic model based on container ID
        let model;
        
        if (id.includes('spirit-nexus')) {
          model = createSphereModel(0x00f3ff);
        } else if (id.includes('neon-torii')) {
          model = createToriiModel();
        } else if (id.includes('ethereal-interface')) {
          model = createInterfaceModel();
        } else if (id.includes('phantom-protocol')) {
          model = createCubeModel(0xff00c8);
        } else if (id.includes('cyber-kappa')) {
          model = createSpiritModel('kappa');
        } else if (id.includes('neon-tengu')) {
          model = createSpiritModel('tengu');
        } else if (id.includes('digital-yurei')) {
          model = createSpiritModel('yurei');
        } else if (id.includes('electric-kitsune')) {
          model = createSpiritModel('kitsune');
        } else if (id.includes('glitch-oni')) {
          model = createSpiritModel('oni');
        } else if (id.includes('hologram-tanuki')) {
          model = createSpiritModel('tanuki');
        }
        
        if (model) {
          scene.add(model);
          
          // Animation loop
          function animate() {
            requestAnimationFrame(animate);
            
            // Rotate model
            model.rotation.y += 0.01;
            
            if (id.includes('ethereal-interface') || id.includes('phantom-protocol')) {
              model.rotation.x += 0.005;
            }
            
            renderer.render(scene, camera);
          }
          
          animate();
        }
      });
      
      // Spirit Database Entries - Create 3D models for detailed view
      const spiritEntries = document.querySelectorAll('.spirit-entry-image');
      
      spiritEntries.forEach(container => {
        const id = container.id;
        const spiritType = id.split('-')[1]; // Extract spirit type
        
        const renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true
        });
        
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.z = 5;
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xc700f3, 1);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);
        
        // Create detailed spirit model
        const model = createDetailedSpiritModel(spiritType);
        scene.add(model);
        
        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          
          // Rotate model
          model.rotation.y += 0.01;
          
          renderer.render(scene, camera);
        }
        
        animate();
      });
    }
    
    // Create Enhanced Sphere Model
    function createSphereModel(color) {
      const group = new THREE.Group();
      
      // Main sphere with complex geometry
      const geometry = new THREE.SphereGeometry(1, 64, 64);
      const material = new THREE.MeshPhongMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: 0.8,
        emissive: color,
        emissiveIntensity: 0.2
      });
      
      const sphere = new THREE.Mesh(geometry, material);
      group.add(sphere);
      
      // Animated inner sphere with noise displacement
      const innerGeometry = new THREE.IcosahedronGeometry(0.8, 3);
      const innerMaterial = new THREE.MeshPhongMaterial({
        color: color,
        transparent: true,
        opacity: 0.3,
        emissive: color,
        emissiveIntensity: 0.4,
        flatShading: true
      });
      
      const innerSphere = new THREE.Mesh(innerGeometry, innerMaterial);
      
      // Displace vertices for more organic look
      const positionAttribute = innerGeometry.attributes.position;
      const vertex = new THREE.Vector3();
      
      for (let i = 0; i < positionAttribute.count; i++) {
        vertex.fromBufferAttribute(positionAttribute, i);
        const noise = 0.05 * Math.sin(10 * vertex.x) * Math.sin(10 * vertex.y) * Math.sin(10 * vertex.z);
        vertex.multiplyScalar(1 + noise);
        positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
      }
      
      group.add(innerSphere);
      
      // Core energy sphere
      const coreGeometry = new THREE.SphereGeometry(0.4, 32, 32);
      const coreMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.8
      });
      
      const core = new THREE.Mesh(coreGeometry, coreMaterial);
      group.add(core);
      
      // Multiple particle rings
      for (let j = 0; j < 3; j++) {
        const ringGeometry = new THREE.BufferGeometry();
        const particles = 120;
        const positions = new Float32Array(particles * 3);
        const radius = 1.3 + j * 0.2;
        
        for (let i = 0; i < particles; i++) {
          const angle = (i / particles) * Math.PI * 2;
          const variation = Math.random() * 0.1;
          positions[i * 3] = Math.cos(angle) * (radius + variation);
          positions[i * 3 + 1] = Math.sin(angle) * (radius + variation);
          positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
        }
        
        ringGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const ringMaterial = new THREE.PointsMaterial({
          color: color,
          size: 0.05 + Math.random() * 0.05,
          transparent: true,
          opacity: 0.6 - j * 0.15,
          blending: THREE.AdditiveBlending
        });
        
        const ring = new THREE.Points(ringGeometry, ringMaterial);
        ring.rotation.x = Math.random() * Math.PI;
        ring.rotation.y = Math.random() * Math.PI;
        
        // Store rotation speed for animation
        ring.userData = {
          rotationSpeed: (0.002 + Math.random() * 0.002) * (Math.random() > 0.5 ? 1 : -1),
          direction: new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
          ).normalize()
        };
        
        group.add(ring);
      }
      
      // Energy beams
      for (let i = 0; i < 8; i++) {
        const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, 2.8, 8);
        beamGeometry.translate(0, 1.4, 0);
        const beamMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending
        });
        
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        beam.rotation.x = Math.PI / 2;
        beam.rotation.z = (i / 8) * Math.PI * 2;
        
        group.add(beam);
      }
      
      // Animated outer energy field
      const fieldGeometry = new THREE.SphereGeometry(1.8, 32, 32);
      const fieldMaterial = new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: 0.1,
        blending: THREE.AdditiveBlending
      });
      
      const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
      field.scale.set(1, 0.8, 1);
      group.add(field);
      
      // Animate components
      const clock = new THREE.Clock();
      
      function animate() {
        const time = clock.getElapsedTime();
        
        // Pulse core
        core.scale.setScalar(0.9 + Math.sin(time * 2) * 0.1);
        core.material.opacity = 0.7 + Math.sin(time * 3) * 0.3;
        
        // Rotate inner sphere
        innerSphere.rotation.x += 0.003;
        innerSphere.rotation.y += 0.005;
        
        // Animate rings
        group.children.forEach(child => {
          if (child.isPoints && child.userData.rotationSpeed) {
            const axis = child.userData.direction;
            child.rotateOnAxis(axis, child.userData.rotationSpeed);
          }
        });
        
        // Animate field
        field.rotation.x += 0.001;
        field.rotation.y += 0.002;
        field.rotation.z += 0.001;
        
        requestAnimationFrame(animate);
      }
      
      animate();
      
      return group;
    }

    
    // Create Enhanced Torii Model
    function createToriiModel() {
      const group = new THREE.Group();
      
      // Material with animated glow
      const glowMaterial = new THREE.MeshPhongMaterial({
        color: 0x00f3ff,
        emissive: 0x00f3ff,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
      });
      
      // Top bar with detailed geometry
      const topShape = new THREE.Shape();
      topShape.moveTo(-1.5, 0);
      topShape.lineTo(1.5, 0);
      topShape.lineTo(1.7, 0.15);
      topShape.lineTo(1.5, 0.3);
      topShape.lineTo(-1.5, 0.3);
      topShape.lineTo(-1.7, 0.15);
      topShape.lineTo(-1.5, 0);
      
      const extrudeSettings = {
        steps: 1,
        depth: 0.3,
        bevelEnabled: true,
        bevelThickness: 0.05,
        bevelSize: 0.05,
        bevelSegments: 3
      };
      
      const topGeometry = new THREE.ExtrudeGeometry(topShape, extrudeSettings);
      const topBar = new THREE.Mesh(topGeometry, glowMaterial);
      topBar.position.y = 1.5;
      topBar.position.z = -0.15;
      group.add(topBar);
      
      // Second top bar with more refined shape
      const secondTopShape = new THREE.Shape();
      secondTopShape.moveTo(-1.75, 0);
      secondTopShape.lineTo(1.75, 0);
      secondTopShape.lineTo(1.85, 0.1);
      secondTopShape.lineTo(1.75, 0.2);
      secondTopShape.lineTo(-1.75, 0.2);
      secondTopShape.lineTo(-1.85, 0.1);
      secondTopShape.lineTo(-1.75, 0);
      
      const secondExtrudeSettings = {
        steps: 1,
        depth: 0.2,
        bevelEnabled: true,
        bevelThickness: 0.03,
        bevelSize: 0.03,
        bevelSegments: 2
      };
      
      const secondTopGeometry = new THREE.ExtrudeGeometry(secondTopShape, secondExtrudeSettings);
      const secondTopBar = new THREE.Mesh(secondTopGeometry, glowMaterial);
      secondTopBar.position.y = 1.2;
      secondTopBar.position.z = -0.1;
      group.add(secondTopBar);
      
      // Pillars with detailed texture
      const pillarGeometry = new THREE.CylinderGeometry(0.15, 0.18, 3, 8);
      
      const leftPillar = new THREE.Mesh(pillarGeometry, glowMaterial);
      leftPillar.position.x = -1.2;
      leftPillar.position.y = 0;
      group.add(leftPillar);
      
      const rightPillar = new THREE.Mesh(pillarGeometry, glowMaterial);
      rightPillar.position.x = 1.2;
      rightPillar.position.y = 0;
      group.add(rightPillar);
      
      // Decorative rings around pillars
      const ringGeometry = new THREE.TorusGeometry(0.18, 0.04, 16, 24);
      const ringMaterial = new THREE.MeshPhongMaterial({
        color: 0x0088ff,
        emissive: 0x0088ff,
        emissiveIntensity: 0.7,
        transparent: true,
        opacity: 0.9
      });
      
      // Add rings to left pillar
      for (let i = 0; i < 5; i++) {
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.x = -1.2;
        ring.position.y = -1.2 + i * 0.6;
        ring.rotation.x = Math.PI / 2;
        group.add(ring);
      }
      
      // Add rings to right pillar
      for (let i = 0; i < 5; i++) {
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.x = 1.2;
        ring.position.y = -1.2 + i * 0.6;
        ring.rotation.x = Math.PI / 2;
        group.add(ring);
      }
      
      // Energy field with animated shader
      const fieldGeometry = new THREE.PlaneGeometry(2.4, 2.8, 20, 20);
      const fieldMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color: { value: new THREE.Color(0x00f3ff) }
        },
        vertexShader: `
          varying vec2 vUv;
          uniform float time;
          
          void main() {
            vUv = uv;
            
            // Create a ripple effect
            vec3 pos = position;
            float amplitude = 0.05;
            float frequency = 2.0;
            float phase = time * 2.0;
            
            pos.z += amplitude * sin(frequency * pos.x + phase) * sin(frequency * pos.y + phase);
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform float time;
          uniform vec3 color;
          
          void main() {
            // Base portal effect
            float distanceFromCenter = length(vUv - vec2(0.5, 0.5)) * 2.0;
            
            // Animated ripples
            float ripples = sin(distanceFromCenter * 20.0 - time * 5.0) * 0.1;
            
            // Energy fluctuations
            float energy = 0.5 + 0.5 * sin(vUv.y * 30.0 + time * 3.0);
            
            // Combine effects
            float alpha = max(0.0, 1.0 - distanceFromCenter) * 0.7;
            alpha += ripples * 0.1;
            alpha *= energy;
            
            gl_FragColor = vec4(color, alpha);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide
      });
      
      const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
      field.position.y = 0.2;
      field.position.z = 0;
      group.add(field);
      
      // Base with detailed geometry
      const baseGeometry = new THREE.BoxGeometry(4, 0.5, 0.5);
      const baseMaterial = new THREE.MeshPhongMaterial({
        color: 0x00f3ff,
        transparent: true,
        opacity: 0.8
      });
      
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -1.5;
      group.add(base);
      
      // Floating character symbols (kanji)
      const symbols = [];
      const symbolCount = 5;
      const symbolGeometry = new THREE.PlaneGeometry(0.4, 0.4);
      
      for (let i = 0; i < symbolCount; i++) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // Draw kanji-like symbol
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, 128, 128);
        ctx.font = 'bold 80px serif';
        ctx.fillStyle = '#00f3ff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Use a random Japanese-looking character
        const chars = ['世', '神', '霊', '門', '天', '鬼', '陰', '陽'];
        ctx.fillText(chars[Math.floor(Math.random() * chars.length)], 64, 64);
        
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        
        const symbolMaterial = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });
        
        const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
        symbol.position.z = 0.05;
        symbol.userData = {
          startY: -0.5 + Math.random(),
          speed: 0.2 + Math.random() * 0.3,
          amplitude: 0.1 + Math.random() * 0.1,
          frequency: 1 + Math.random() * 2
        };
        
        symbols.push(symbol);
        group.add(symbol);
      }
      
      // Background energy particles
      const particlesGeometry = new THREE.BufferGeometry();
      const particleCount = 100;
      const positionArray = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        // Position particles in a plane shape behind the torii
        positionArray[i3] = (Math.random() - 0.5) * 2.2; // x
        positionArray[i3 + 1] = (Math.random() - 0.5) * 2.8; // y
        positionArray[i3 + 2] = -0.2 - Math.random() * 0.3; // z slightly behind
      }
      
      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      
      const particleMaterial = new THREE.PointsMaterial({
        color: 0x00f3ff,
        size: 0.05,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      
      const particles = new THREE.Points(particlesGeometry, particleMaterial);
      group.add(particles);
      
      // Ground reflection plane
      const reflectionGeometry = new THREE.PlaneGeometry(3.5, 1);
      const reflectionMaterial = new THREE.MeshBasicMaterial({
        color: 0x00f3ff,
        transparent: true,
        opacity: 0.2,
        blending: THREE.AdditiveBlending
      });
      
      const reflection = new THREE.Mesh(reflectionGeometry, reflectionMaterial);
      reflection.rotation.x = -Math.PI / 2;
      reflection.position.y = -1.75;
      group.add(reflection);
      
      // Animated light beams
      const beams = [];
      const beamCount = 3;
      
      for (let i = 0; i < beamCount; i++) {
        const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, 3, 8);
        const beamMaterial = new THREE.MeshBasicMaterial({
          color: 0x00f3ff,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending
        });
        
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        beam.rotation.z = Math.PI / 2;
        beam.position.z = -0.1 - i * 0.1;
        beam.scale.x = 0.2;
        beam.userData = {
          phase: Math.random() * Math.PI * 2,
          speed: 0.02 + Math.random() * 0.03
        };
        
        beams.push(beam);
        group.add(beam);
      }
      
      // Animation logic
      const clock = new THREE.Clock();
      
      function animate() {
        const time = clock.getElapsedTime();
        
        // Animate energy field
        if (field.material.uniforms) {
          field.material.uniforms.time.value = time;
        }
        
        // Animate floating symbols
        symbols.forEach((symbol, i) => {
          const data = symbol.userData;
          symbol.position.y = data.startY + Math.sin(time * data.frequency) * data.amplitude;
          symbol.position.x = (Math.sin(time * 0.5 + i) * 0.5) * Math.sin(time * 0.2);
          symbol.material.opacity = 0.5 + Math.sin(time * 2 + i) * 0.3;
        });
        
        // Animate light beams
        beams.forEach(beam => {
          const phase = beam.userData.phase;
          const speed = beam.userData.speed;
          beam.position.y = Math.sin(time * speed + phase) * 1.5;
          beam.material.opacity = 0.2 + Math.sin(time * speed * 2 + phase) * 0.1;
        });
        
        // Pulse material glow
        const pulseIntensity = 0.5 + Math.sin(time * 2) * 0.2;
        glowMaterial.emissiveIntensity = pulseIntensity;
        
        requestAnimationFrame(animate);
      }
      
      animate();
      
      return group;
    }
    
    // Create Enhanced Interface Model
    function createInterfaceModel() {
      const group = new THREE.Group();
      
      // Materials
      const hologramMaterial = new THREE.MeshBasicMaterial({
        color: 0x00f3ff,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
      });
      
      const glowingMaterial = new THREE.MeshPhongMaterial({
        color: 0x00f3ff,
        emissive: 0x00f3ff,
        emissiveIntensity: 0.7,
        transparent: true,
        opacity: 0.9
      });
      
      // Create central sphere with complex structure
      const sphereGroup = new THREE.Group();
      
      // Core orb with animated texture
      const orbGeometry = new THREE.SphereGeometry(0.5, 32, 32);
      
      // Create animated texture for the orb
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      const drawCanvasTexture = (time) => {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, 256, 256);
        
        // Draw circular patterns
        ctx.strokeStyle = '#00f3ff';
        for (let i = 0; i < 10; i++) {
          const size = 20 + i * 15;
          const offset = (time * (i + 1) * 0.1) % (Math.PI * 2);
          
          ctx.beginPath();
          ctx.arc(128, 128, size, offset, offset + Math.PI * 1.2);
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        // Draw grid overlay
        ctx.strokeStyle = 'rgba(0, 243, 255, 0.5)';
        ctx.lineWidth = 1;
        
        // Vertical lines
        for (let x = 0; x < 256; x += 16) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, 256);
          ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = 0; y < 256; y += 16) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(256, y);
          ctx.stroke();
        }
        
        // Add some random glitch effects
        if (Math.random() > 0.95) {
          ctx.fillStyle = 'rgba(0, 243, 255, 0.3)';
          ctx.fillRect(
            Math.random() * 200,
            Math.random() * 200,
            Math.random() * 50 + 20,
            Math.random() * 50 + 20
          );
        }
        
        // Add digital symbols
        ctx.font = '16px monospace';
        ctx.fillStyle = '#00f3ff';
        
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * 236 + 10;
          const y = Math.random() * 236 + 10;
          const symbols = ['0', '1', '#', '*', '>', '<', '$', '%', '&'];
          ctx.fillText(symbols[Math.floor(Math.random() * symbols.length)], x, y);
        }
      };
      
      // Create texture
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      
      const orbMaterial = new THREE.MeshPhongMaterial({
        map: texture,
        emissive: 0x00f3ff,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
      });
      
      const orb = new THREE.Mesh(orbGeometry, orbMaterial);
      sphereGroup.add(orb);
      
      // Energy rings around core
      const ringCount = 3;
      const rings = [];
      
      for (let i = 0; i < ringCount; i++) {
        const ringGeometry = new THREE.TorusGeometry(0.6 + i * 0.15, 0.02, 16, 50);
        const ring = new THREE.Mesh(ringGeometry, glowingMaterial.clone());
        ring.rotation.x = Math.PI / 2;
        ring.rotation.y = Math.PI / 4 * i;
        ring.userData = { rotationAxis: new THREE.Vector3(
          Math.random() - 0.5,
          Math.random() - 0.5,
          Math.random() - 0.5
        ).normalize() };
        rings.push(ring);
        sphereGroup.add(ring);
      }
      
      // Particle system around core
      const particleCount = 200;
      const particleGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const colors = new Float32Array(particleCount * 3);
      
      const color1 = new THREE.Color(0x00f3ff);
      const color2 = new THREE.Color(0x0088ff);
      
      for (let i = 0; i < particleCount; i++) {
        // Distribute particles in a spherical shell
        const radius = 0.7 + Math.random() * 0.3;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = radius * Math.cos(phi);
        
        sizes[i] = Math.random() * 0.05 + 0.01;
        
        const mixFactor = Math.random();
        const blendedColor = color1.clone().lerp(color2, mixFactor);
        colors[i * 3] = blendedColor.r;
        colors[i * 3 + 1] = blendedColor.g;
        colors[i * 3 + 2] = blendedColor.b;
      }
      
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      // Custom shader material for particles
      const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          pointTexture: { value: new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/textures/sprites/spark1.png') }
        },
        vertexShader: `
          attribute float size;
          attribute vec3 color;
          varying vec3 vColor;
          uniform float time;
          
          void main() {
            vColor = color;
            
            // Calculate position with time-based movement
            vec3 pos = position;
            float noise = sin(position.x * 10.0 + time) * cos(position.y * 8.0 + time) * sin(position.z * 6.0 + time) * 0.05;
            pos += pos * noise;
            
            // Project position
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform sampler2D pointTexture;
          varying vec3 vColor;
          
          void main() {
            gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
          }
        `,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
      });
      
      const particles = new THREE.Points(particleGeometry, particleMaterial);
      sphereGroup.add(particles);
      
      group.add(sphereGroup);
      
      // Create holographic screens with detailed UI elements
      const screenCount = 5;
      const screens = [];
      
      for (let i = 0; i < screenCount; i++) {
        const screen = new THREE.Group();
        const angle = (i / screenCount) * Math.PI * 2;
        
        // Screen base
        const screenGeometry = new THREE.PlaneGeometry(1.5, 1, 10, 10);
        
        // Create detailed UI texture for each screen
        const screenCanvas = document.createElement('canvas');
        screenCanvas.width = 512;
        screenCanvas.height = 340;
        const screenCtx = screenCanvas.getContext('2d');
        
        // Draw screen UI elements (different for each screen)
        drawInterfaceScreen(screenCtx, i);
        
        const screenTexture = new THREE.CanvasTexture(screenCanvas);
        const screenMaterial = new THREE.MeshBasicMaterial({
          map: screenTexture,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });
        
        const screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
        screen.add(screenMesh);
        
        // Add frame to screen
        const frameGeometry = new THREE.BoxGeometry(1.6, 1.1, 0.05);
        const frameMaterial = new THREE.MeshPhongMaterial({
          color: 0x00aaff,
          emissive: 0x003366,
          transparent: true,
          opacity: 0.7
        });
        
        const frame = new THREE.Mesh(frameGeometry, frameMaterial);
        frame.position.z = -0.05;
        screen.add(frame);
        
        // Position and rotate the screen
        screen.position.x = Math.cos(angle) * 1.5;
        screen.position.z = Math.sin(angle) * 1.5;
        screen.rotation.y = -angle;
        
        // Add connection beam to central sphere
        const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1.3, 8);
        const beamMaterial = new THREE.MeshBasicMaterial({
          color: 0x00f3ff,
          transparent: true,
          opacity: 0.4,
          blending: THREE.AdditiveBlending
        });
        
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        beam.rotation.z = Math.PI / 2;
        
        // Position beam to connect screen and sphere
        const beamDistance = Math.sqrt(Math.pow(screen.position.x, 2) + Math.pow(screen.position.z, 2));
        beam.position.x = screen.position.x / 2;
        beam.position.z = screen.position.z / 2;
        beam.scale.x = beamDistance / 1.3;
        
        screen.userData = {
          floatPhase: Math.random() * Math.PI * 2,
          floatSpeed: 0.5 + Math.random() * 0.5,
          floatAmplitude: 0.05 + Math.random() * 0.05,
          originalY: screen.position.y,
          beamPulseRate: 1 + Math.random()
        };
        
        screens.push(screen);
        group.add(screen);
        group.add(beam);
      }
      
      // Add data stream trails
      const trailCount = 15;
      const trails = [];
      
      for (let i = 0; i < trailCount; i++) {
        const trailGeometry = new THREE.TubeGeometry(
          new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 2
            ),
            new THREE.Vector3(
              (Math.random() - 0.5) * 3,
              (Math.random() - 0.5) * 3,
              (Math.random() - 0.5) * 3
            )
          ]),
          20, // tubular segments
          0.01, // radius
          8, // radial segments
          false // closed
        );
        
        const trailMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            color: { value: new THREE.Color(0x00ffff) }
          },
          vertexShader: `
            varying vec2 vUv;
            uniform float time;
            
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            varying vec2 vUv;
            uniform float time;
            uniform vec3 color;
            
            void main() {
              float pulse = mod(vUv.x - time * 0.5, 1.0);
              pulse = smoothstep(0.0, 0.2, pulse) * smoothstep(0.6, 0.4, pulse);
              
              gl_FragColor = vec4(color, pulse * 0.6);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending
        });
        
        const trail = new THREE.Mesh(trailGeometry, trailMaterial);
        trail.userData = {
          pulseSpeed: 0.2 + Math.random() * 0.3
        };
        
        trails.push(trail);
        group.add(trail);
      }
      
      // Animation loop
      const clock = new THREE.Clock();
      
      function animate() {
        const time = clock.getElapsedTime();
        
        // Update orb texture
        drawCanvasTexture(time);
        orb.material.map.needsUpdate = true;
        
        // Rotate rings
        rings.forEach((ring, i) => {
          ring.rotateOnAxis(ring.userData.rotationAxis, 0.01 + i * 0.005);
          ring.material.opacity = 0.6 + Math.sin(time * 2 + i) * 0.2;
          ring.material.emissiveIntensity = 0.5 + Math.sin(time * 1.5 + i) * 0.2;
        });
        
        // Update particle animation
        if (particles.material.uniforms) {
          particles.material.uniforms.time.value = time;
        }
        
        // Animate screens
        screens.forEach((screen, i) => {
          const data = screen.userData;
          // Float up and down
          screen.position.y = data.originalY + Math.sin(time * data.floatSpeed + data.floatPhase) * data.floatAmplitude;
          
          // Update screen texture if needed (like displaying time or animations)
          if (time % 3 < 0.1) { // Update every ~3 seconds
            drawInterfaceScreen(screen.children[0].material.map.image.getContext('2d'), i);
            screen.children[0].material.map.needsUpdate = true;
          }
        });
        
        // Animate data trails
        trails.forEach((trail, i) => {
          if (trail.material.uniforms) {
            trail.material.uniforms.time.value = time * trail.userData.pulseSpeed;
          }
        });
        
        // Rotate the entire interface slowly
        sphereGroup.rotation.y += 0.002;
        
        requestAnimationFrame(animate);
      }
      
      animate();
      
      return group;
      
      // Helper function to draw interface screens
      function drawInterfaceScreen(ctx, screenIndex) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        // Clear canvas
        ctx.fillStyle = 'rgba(0, 20, 40, 0.8)';
        ctx.fillRect(0, 0, width, height);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(0, 200, 255, 0.3)';
        ctx.lineWidth = 1;
        
        // Vertical grid lines
        for (let x = 0; x < width; x += 32) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        
        // Horizontal grid lines
        for (let y = 0; y < height; y += 32) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
        
        // Draw different content based on screen index
        switch (screenIndex % 5) {
          case 0: // Data analysis screen
            drawDataScreen(ctx);
            break;
          case 1: // Spirit visualization
            drawSpiritScreen(ctx);
            break;
          case 2: // Network topology
            drawNetworkScreen(ctx);
            break;
          case 3: // Sacred geometry
            drawGeometryScreen(ctx);
            break;
          case 4: // Ritual incantations
            drawIncantationScreen(ctx);
            break;
        }
        
        // Common elements: header and footer
        ctx.fillStyle = 'rgba(0, 100, 180, 0.5)';
        ctx.fillRect(0, 0, width, 30);
        ctx.fillRect(0, height - 30, width, 30);
        
        // Header text
        ctx.font = 'bold 18px monospace';
        ctx.fillStyle = '#00f3ff';
        ctx.textAlign = 'center';
        
        const headers = ["DATA ANALYSIS", "SPIRIT VISUALIZER", "NETWORK TOPOLOGY", "SACRED GEOMETRY", "RITUAL MATRIX"];
        ctx.fillText(headers[screenIndex % 5], width / 2, 20);
        
        // Footer text
        ctx.font = '14px monospace';
        ctx.fillText(`SYSTEM ACTIVE • NODE ${screenIndex + 1} • ENERGY: ${Math.floor(Math.random() * 100)}%`, width / 2, height - 10);
        
        // Add some glitch effects occasionally
        if (Math.random() > 0.85) {
          ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
          ctx.fillRect(
            Math.random() * width * 0.8,
            30 + Math.random() * (height - 60),
            Math.random() * 100 + 20,
            Math.random() * 10 + 5
          );
        }
      }
      
      // Helper functions for drawing different screen types
      function drawDataScreen(ctx) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        // Draw bar chart
        ctx.fillStyle = '#00f3ff';
        for (let i = 0; i < 8; i++) {
          const barHeight = Math.random() * 100 + 20;
          ctx.fillRect(50 + i * 50, height - 40 - barHeight, 30, barHeight);
        }
        
        // Draw axis lines
        ctx.strokeStyle = '#00f3ff';
        ctx.beginPath();
        ctx.moveTo(40, 40);
        ctx.lineTo(40, height - 40);
        ctx.lineTo(width - 40, height - 40);
        ctx.stroke();
        
        // Draw random data points
        ctx.fillStyle = '#ffaa00';
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * (width - 100) + 50;
          const y = Math.random() * (height - 100) + 50;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      function drawSpiritScreen(ctx) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        // Draw spirit visualization (ghostly pattern)
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Create gradient
        const gradient = ctx.createRadialGradient(
          centerX, centerY, 20,
          centerX, centerY, 150
        );
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
        gradient.addColorStop(0.5, 'rgba(0, 100, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(0, 50, 200, 0)');
        
        // Draw multiple layer of spirit "aura"
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.fillStyle = gradient;
          ctx.arc(
            centerX + Math.sin(Date.now() * 0.001 * (i + 1)) * 10,
            centerY + Math.cos(Date.now() * 0.001 * (i + 1)) * 10,
            100 - i * 15,
            0, Math.PI * 2
          );
          ctx.fill();
        }
        
        // Draw spirit features
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.arc(centerX - 30, centerY - 20, 10, 0, Math.PI * 2); // Left eye
        ctx.arc(centerX + 30, centerY - 20, 10, 0, Math.PI * 2); // Right eye
        ctx.fill();
      }
      
       function drawNetworkScreen(ctx) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        // Draw network nodes
        const nodeCount = 8;
        const nodes = [];
        
        for (let i = 0; i < nodeCount; i++) {
          nodes.push({
            x: 100 + Math.random() * (width - 200),
            y: 100 + Math.random() * (height - 200),
            size: 10 + Math.random() * 20
          });
        }
        
        // Draw connections
        ctx.strokeStyle = 'rgba(0, 200, 255, 0.4)';
        ctx.lineWidth = 2;
        
        for (let i = 0; i < nodeCount; i++) {
          for (let j = i + 1; j < nodeCount; j++) {
            if (Math.random() > 0.3) {
              ctx.beginPath();
              ctx.moveTo(nodes[i].x, nodes[i].y);
              ctx.lineTo(nodes[j].x, nodes[j].y);
              ctx.stroke();
            }
          }
        }
        
        // Draw nodes
        nodes.forEach((node, index) => {
          // Glowing effect
          const gradient = ctx.createRadialGradient(
            node.x, node.y, 0,
            node.x, node.y, node.size
          );
          gradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
          gradient.addColorStop(0.5, 'rgba(0, 200, 255, 0.5)');
          gradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Node label
          ctx.font = '12px monospace';
          ctx.fillStyle = '#00f3ff';
          ctx.textAlign = 'center';
          ctx.fillText(`NODE ${index + 1}`, node.x, node.y + node.size + 15);
        });
      }
      
      function drawGeometryScreen(ctx) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        // Draw sacred geometry pattern
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = 120;
        
        // Draw circles
        ctx.strokeStyle = '#00f3ff';
        ctx.lineWidth = 1;
        
        // Flower of Life pattern
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const x = centerX + Math.cos(angle) * radius / 2;
          const y = centerY + Math.sin(angle) * radius / 2;
          
          ctx.beginPath();
          ctx.arc(x, y, radius / 2, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Center circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius / 2, 0, Math.PI * 2);
        ctx.stroke();
        
        // Outer circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Star pattern
        ctx.beginPath();
        const points = 6;
        for (let i = 0; i < points * 2; i++) {
          const angle = (i / (points * 2)) * Math.PI * 2;
          const r = i % 2 === 0 ? radius : radius / 2;
          const x = centerX + Math.cos(angle) * r;
          const y = centerY + Math.sin(angle) * r;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.stroke();
        
        // Add some runes around the edge
        ctx.font = '16px monospace';
        ctx.fillStyle = '#00f3ff';
        ctx.textAlign = 'center';
        
        const runes = ['ᚠ', 'ᚢ', 'ᚦ', 'ᚨ', 'ᚱ', 'ᚲ', 'ᚷ', 'ᚹ', 'ᚺ', 'ᚾ', 'ᛁ', 'ᛃ'];
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const x = centerX + Math.cos(angle) * (radius + 30);
          const y = centerY + Math.sin(angle) * (radius + 30);
          
          ctx.fillText(runes[i % runes.length], x, y);
        }
      }
      
      function drawIncantationScreen(ctx) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        // Draw ritual text and symbols
        ctx.font = '16px monospace';
        ctx.fillStyle = '#00f3ff';
        ctx.textAlign = 'left';
        
        const incantations = [
          "INIT ETHEREAL PROTOCOL",
          "SUMMON DIGITAL ENTITY",
          "ESTABLISH NEON CONNECTION",
          "BIND PHANTOM DATA",
          "INVOKE CYBER SPIRIT",
          "MANIFEST NETWORK YOKAI",
          "DECRYPT SPECTRAL CODE",
          "CHANNEL QUANTUM ESSENCE"
        ];
        
        for (let i = 0; i < incantations.length; i++) {
          ctx.fillText(incantations[i], 40, 60 + i * 30);
          
          // Add status indicators
          ctx.fillStyle = Math.random() > 0.3 ? '#00ff00' : '#ff9900';
          ctx.beginPath();
          ctx.arc(25, 60 + i * 30 - 5, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#00f3ff';
        }
        
        // Draw magic circle
        ctx.strokeStyle = '#c700f3';
        ctx.beginPath();
        ctx.arc(width - 100, height / 2, 70, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner circle
        ctx.beginPath();
        ctx.arc(width - 100, height / 2, 50, 0, Math.PI * 2);
        ctx.stroke();
        
        // Magic symbols inside circle
        ctx.font = '20px serif';
        ctx.textAlign = 'center';
        
        const symbols = ['⚶', '⚸', '⚷', '⚹', '⚺', '⚻', '⚼'];
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2;
          const x = width - 100 + Math.cos(angle) * 60;
          const y = height / 2 + Math.sin(angle) * 60;
          
          ctx.fillText(symbols[i % symbols.length], x, y);
        }
        
        // Center symbol
        ctx.font = '36px serif';
        ctx.fillText('⍟', width - 100, height / 2 + 12);
      }
    }
    
    // Create Enhanced Cube Model
    function createCubeModel(color) {
      const group = new THREE.Group();
      
      // Create main cube with interesting geometry
      const mainGeometry = new THREE.BoxGeometry(1, 1, 1);
      const mainMaterial = new THREE.MeshPhongMaterial({
        color: color,
        transparent: true,
        opacity: 0.7,
        wireframe: false,
        emissive: color,
        emissiveIntensity: 0.3
      });
      
      const cube = new THREE.Mesh(mainGeometry, mainMaterial);
      group.add(cube);
      
      // Create wireframe overlay
      const wireGeometry = new THREE.BoxGeometry(1.1, 1.1, 1.1);
      const wireMaterial = new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: 0.3
      });
      
      const wireframe = new THREE.Mesh(wireGeometry, wireMaterial);
      group.add(wireframe);
      
      // Create outer containment field
      const fieldGeometry = new THREE.BoxGeometry(1.4, 1.4, 1.4);
      const fieldMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color: { value: new THREE.Color(color) }
        },
        vertexShader: `
          varying vec3 vPosition;
          
          void main() {
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color;
          varying vec3 vPosition;
          
          void main() {
            // Calculate distance from edges
            vec3 absPos = abs(vPosition);
            float maxComponent = max(max(absPos.x, absPos.y), absPos.z);
            float distFromEdge = 0.7 - maxComponent;
            
            // Pulse effect based on time
            float pulse = sin(time * 3.0) * 0.2 + 0.8;
            
            // Edge highlighting
            float edgeGlow = smoothstep(0.05, 0.0, distFromEdge) * pulse;
            
            // Face highlighting
            float faceOpacity = smoothstep(0.0, 0.05, distFromEdge) * 0.3;
            
            gl_FragColor = vec4(color, edgeGlow + faceOpacity);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      
      const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
      group.add(field);
      
      // Add glitch cubes inside
      const glitchCount = 15;
      const glitchCubes = [];
      
      for (let i = 0; i < glitchCount; i++) {
        const size = 0.1 + Math.random() * 0.3;
        const glitchGeometry = new THREE.BoxGeometry(size, size, size);
        const glitchMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.5 + Math.random() * 0.5
        });
        
        const glitch = new THREE.Mesh(glitchGeometry, glitchMaterial);
        
        // Position inside the main cube
        glitch.position.set(
          (Math.random() - 0.5) * 0.7,
          (Math.random() - 0.5) * 0.7,
          (Math.random() - 0.5) * 0.7
        );
        
        glitch.userData = {
          originalPos: glitch.position.clone(),
          phaseX: Math.random() * Math.PI * 2,
          phaseY: Math.random() * Math.PI * 2,
          phaseZ: Math.random() * Math.PI * 2,
          frequency: 1 + Math.random() * 2,
          amplitude: 0.05 + Math.random() * 0.2
        };
        
        glitchCubes.push(glitch);
        group.add(glitch);
      }
      
      // Add particle system
      const particleCount = 200;
      const particleGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        // Position particles in a cube shape
        positions[i * 3] = (Math.random() - 0.5) * 2;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
      }
      
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const particleMaterial = new THREE.PointsMaterial({
        color: color,
        size: 0.03,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
      });
      
      const particles = new THREE.Points(particleGeometry, particleMaterial);
      group.add(particles);
      
      // Add Energy connections between the center and random points in the field
      const connectionCount = 8;
      const connections = [];
      
      for (let i = 0; i < connectionCount; i++) {
        const lineGeometry = new THREE.BufferGeometry();
        const lineMaterial = new THREE.LineBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.5,
          blending: THREE.AdditiveBlending
        });
        
        // Create point array for the line
        const points = [];
        points.push(new THREE.Vector3(0, 0, 0)); // Center
        
        // End point on the cube surface
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const endPoint = new THREE.Vector3(
          0.7 * Math.sin(phi) * Math.cos(theta),
          0.7 * Math.sin(phi) * Math.sin(theta),
          0.7 * Math.cos(phi)
        );
        points.push(endPoint);
        
        lineGeometry.setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        line.userData = {
          endPoint: endPoint.clone(),
          pulseRate: 1 + Math.random() * 2
        };
        
        connections.push(line);
        group.add(line);
      }
      
      // Animation setup
      const clock = new THREE.Clock();
      
      function animate() {
        const time = clock.getElapsedTime();
        
        // Update field shader time
        if (field.material.uniforms) {
          field.material.uniforms.time.value = time;
        }
        
        // Animate glitch cubes
        glitchCubes.forEach(glitch => {
          const data = glitch.userData;
          
          // Oscillate position
          glitch.position.x = data.originalPos.x + Math.sin(time * data.frequency + data.phaseX) * data.amplitude;
          glitch.position.y = data.originalPos.y + Math.sin(time * data.frequency + data.phaseY) * data.amplitude;
          glitch.position.z = data.originalPos.z + Math.sin(time * data.frequency + data.phaseZ) * data.amplitude;
          
          // Random scale changes and occasional "glitches"
          if (Math.random() > 0.99) {
            glitch.scale.set(
              Math.random() * 1.5 + 0.5,
              Math.random() * 1.5 + 0.5,
              Math.random() * 1.5 + 0.5
            );
            
            // Also offset position during glitch
            glitch.position.add(new THREE.Vector3(
              (Math.random() - 0.5) * 0.3,
              (Math.random() - 0.5) * 0.3,
              (Math.random() - 0.5) * 0.3
            ));
            
            // Reset after brief delay
            setTimeout(() => {
              glitch.scale.set(1, 1, 1);
              glitch.position.copy(data.originalPos);
            }, 100);
          }
          
          // Pulse opacity
          glitch.material.opacity = 0.5 + Math.sin(time * 3 + data.phaseX) * 0.3;
        });
        
        // Animate energy connections
        connections.forEach(line => {
          const pulseRate = line.userData.pulseRate;
          line.material.opacity = 0.3 + Math.sin(time * pulseRate) * 0.2;
        });
        
        // Pulse main cube
        const pulseScale = 1 + Math.sin(time * 2) * 0.05;
        cube.scale.set(pulseScale, pulseScale, pulseScale);
        
        // Rotate wireframe oppositely to main cube for interesting effect
        wireframe.rotation.y = -time * 0.2;
        wireframe.rotation.z = -time * 0.1;
        
        requestAnimationFrame(animate);
      }
      
      animate();
      
      return group;
    }
    
    // Create Spirit Model
    function createSpiritModel(type) {
      const group = new THREE.Group();
      
      let color, shape, particleConfig;
      
      // Define characteristics based on spirit type
      switch(type) {
        case 'kappa':
          color = 0x00f3ff; // Cyan for water
          shape = 'sphere';
          particleConfig = {
            count: 200,
            size: 0.04,
            speed: 1.2,
            flowPattern: 'water'
          };
          break;
        case 'tengu':
          color = 0x00ffaa; // Green/cyan for wind
          shape = 'wings';
          particleConfig = {
            count: 150,
            size: 0.05,
            speed: 2,
            flowPattern: 'wind'
          };
          break;
        case 'yurei':
          color = 0xc0c0ff; // Ghostly blue
          shape = 'wisp';
          particleConfig = {
            count: 250,
            size: 0.03,
            speed: 0.8,
            flowPattern: 'ghost'
          };
          break;
        case 'kitsune':
          color = 0xff6600; // Fox orange
          shape = 'fox';
          particleConfig = {
            count: 180,
            size: 0.035,
            speed: 1.5,
            flowPattern: 'electric'
          };
          break;
        case 'oni':
          color = 0xff0066; // Oni red
          shape = 'horns';
          particleConfig = {
            count: 120,
            size: 0.05,
            speed: 1,
            flowPattern: 'glitch'
          };
          break;
        case 'tanuki':
          color = 0x66ff33; // Playful green
          shape = 'round';
          particleConfig = {
            count: 160,
            size: 0.04,
            speed: 1.3,
            flowPattern: 'playful'
          };
          break;
        default:
          color = 0x00f3ff; // Default cyan
          shape = 'sphere';
          particleConfig = {
            count: 200,
            size: 0.03,
            speed: 1,
            flowPattern: 'default'
          };
      }
      
      // Create basic core shape
      let core;
      switch(shape) {
        case 'sphere':
          core = createWaterSpiritCore();
          break;
        case 'wings':
          core = createWingSpiritCore();
          break;
        case 'wisp':
          core = createWispSpiritCore();
          break;
        case 'fox':
          core = createFoxSpiritCore();
          break;
        case 'horns':
          core = createHornSpiritCore();
          break;
        case 'round':
          core = createRoundSpiritCore();
          break;
        default:
          core = createDefaultSpiritCore();
      }
      
      group.add(core);
      
      // Create particle system based on config
      const particleSystem = createSpiritParticles(particleConfig);
      group.add(particleSystem);
      
      // Create aura glow
      const aura = createSpiritAura(color, shape);
      group.add(aura);
      
      // Add spirit-specific details
      switch(type) {
        case 'kappa':
          addKappaDetails(group, color);
          break;
        case 'tengu':
          addTenguDetails(group, color);
          break;
        case 'yurei':
          addYureiDetails(group, color);
          break;
        case 'kitsune':
          addKitsuneDetails(group, color);
          break;
        case 'oni':
          addOniDetails(group, color);
          break;
        case 'tanuki':
          addTanukiDetails(group, color);
          break;
      }
      
      // Animate the spirit
      animateSpirit(group, type);
      
      return group;
      
      // Helper functions for creating specific spirit shapes
      
      function createWaterSpiritCore() {
        const geometry = new THREE.SphereGeometry(0.5, 32, 32);
        const material = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.7,
          emissive: color,
          emissiveIntensity: 0.5
        });
        
        const sphere = new THREE.Mesh(geometry, material);
        
        // Add water ripple effect
        const ripples = [];
        for (let i = 0; i < 3; i++) {
          const rippleGeo = new THREE.RingGeometry(0.6 + i * 0.15, 0.65 + i * 0.15, 30);
          const rippleMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
          });
          const ripple = new THREE.Mesh(rippleGeo, rippleMat);
          ripple.rotation.x = Math.PI / 2;
          ripple.userData = { 
            speed: 0.5 - i * 0.1,
            maxScale: 1.5 + i * 0.2,
            phase: i * Math.PI / 3
          };
          ripples.push(ripple);
          sphere.add(ripple);
        }
        
        // Animate ripples
        function animateRipples() {
          const time = Date.now() * 0.001;
          
          ripples.forEach(ripple => {
            const data = ripple.userData;
            const cyclePos = ((time * data.speed) + data.phase) % 1;
            
            // Scale up and fade out
            const scale = 1 + cyclePos * (data.maxScale - 1);
            ripple.scale.set(scale, scale, scale);
            ripple.material.opacity = 0.4 * (1 - cyclePos);
          });
          
          requestAnimationFrame(animateRipples);
        }
        
        animateRipples();
        
        return sphere;
      }
      
      function createWingSpiritCore() {
        const group = new THREE.Group();
        
        // Core body
        const bodyGeo = new THREE.SphereGeometry(0.3, 32, 32);
        const bodyMat = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.8,
          emissive: color,
          emissiveIntensity: 0.5
        });
        
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        
        // Wings
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.quadraticCurveTo(0.5, 1, 1, 0);
        wingShape.quadraticCurveTo(0.5, 0.8, 0, 0);
        
        const wingGeo = new THREE.ShapeGeometry(wingShape);
        const wingMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        
        // Left wing
        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.set(-0.3, 0, 0);
        leftWing.rotation.z = Math.PI / 6;
        leftWing.scale.set(0.5, 0.5, 0.5);
        group.add(leftWing);
        
        // Right wing
        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.position.set(0.3, 0, 0);
        rightWing.rotation.z = -Math.PI / 6;
        rightWing.scale.set(0.5, 0.5, 0.5);
        group.add(rightWing);
        
        // Animate wings
        function animateWings() {
          const time = Date.now() * 0.003;
          const wingFlapAmount = Math.sin(time) * 0.5;
          
          leftWing.rotation.z = Math.PI / 6 + wingFlapAmount;
          rightWing.rotation.z = -Math.PI / 6 - wingFlapAmount;
          
          requestAnimationFrame(animateWings);
        }
        
        animateWings();
        
        return group;
      }
      
      function createWispSpiritCore() {
        const group = new THREE.Group();
        
        // Create multiple layered transparent shapes for ghostly effect
        for (let i = 0; i < 5; i++) {
          const wispGeo = new THREE.SphereGeometry(0.4 - i * 0.05, 16, 16);
          const wispMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.2 - i * 0.03
          });
          
          const wisp = new THREE.Mesh(wispGeo, wispMat);
          wisp.position.y = -0.2 + i * 0.1;
          wisp.scale.y = 1.5 + i * 0.2;
          wisp.userData = { 
            floatSpeed: 0.5 + i * 0.2,
            floatOffset: i * Math.PI / 3
          };
          
          group.add(wisp);
        }
        
        // Create trailing wisps
        for (let i = 0; i < 15; i++) {
          const trailGeo = new THREE.SphereGeometry(0.1 - i * 0.005, 8, 8);
          const trailMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.3 - i * 0.02
          });
          
          const trail = new THREE.Mesh(trailGeo, trailMat);
          trail.position.y = -0.4 - i * 0.08;
          trail.userData = {
            waveSpeed: 1 + i * 0.2,
            waveAmplitude: 0.05 + i * 0.003
          };
          
          group.add(trail);
        }
        
        // Animate ghostly movement
        function animateWisp() {
          const time = Date.now() * 0.001;
          
          group.children.forEach(child => {
            if (child.userData.floatSpeed) {
              // For main wisp parts
              child.position.y = -0.2 + Math.sin(time * child.userData.floatSpeed + child.userData.floatOffset) * 0.1;
              child.scale.y = 1.5 + Math.sin(time * 1.5 + child.userData.floatOffset) * 0.2;
            } else if (child.userData.waveSpeed) {
              // For trailing wisps
              const waveX = Math.sin(time * child.userData.waveSpeed) * child.userData.waveAmplitude;
              child.position.x = waveX;
            }
          });
          
          requestAnimationFrame(animateWisp);
        }
        
        animateWisp();
        
        return group;
      }
      
      function createFoxSpiritCore() {
        const group = new THREE.Group();
        
        // Fox head (simplified)
        const headGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const headMat = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.9,
          emissive: color,
          emissiveIntensity: 0.3
        });
        
        // Distort sphere to make it more fox-like
        const positionAttr = headGeo.getAttribute('position');
        const vertex = new THREE.Vector3();
        
        for (let i = 0; i < positionAttr.count; i++) {
          vertex.fromBufferAttribute(positionAttr, i);
          
          // Elongate in z-direction for snout
          if (vertex.z > 0) {
            vertex.z *= 1.5;
          }
          
          // Point the ears
          if (vertex.y > 0.15 && Math.abs(vertex.x) > 0.15) {
            vertex.y *= 1.6;
          }
          
          positionAttr.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        
        headGeo.computeVertexNormals();
        const head = new THREE.Mesh(headGeo, headMat);
        group.add(head);
        
        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.12, 0.05, 0.2);
        group.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.12, 0.05, 0.2);
        group.add(rightEye);
        
        // Pupils
        // Pupils
        const pupilGeo = new THREE.SphereGeometry(0.02, 8, 8);
        const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
        leftPupil.position.set(-0.12, 0.05, 0.24);
        group.add(leftPupil);
        
        const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
        rightPupil.position.set(0.12, 0.05, 0.24);
        group.add(rightPupil);
        
        // Electric aura tail
        const tailCount = 9;
        const tails = [];
        
        for (let i = 0; i < tailCount; i++) {
          const tailGeo = new THREE.CylinderGeometry(0.03 - i * 0.003, 0.02 - i * 0.002, 0.3 + i * 0.06, 8);
          const tailMat = new THREE.MeshPhongMaterial({
            color: color,
            transparent: true,
            opacity: 0.7 - i * 0.05,
            emissive: color,
            emissiveIntensity: 0.5
          });
          
          const tail = new THREE.Mesh(tailGeo, tailMat);
          tail.position.z = -0.15 - i * 0.1;
          tail.rotation.x = Math.PI / 2;
          tail.userData = {
            waveFreq: 3 + i * 0.2,
            waveAmp: 0.1 + i * 0.02,
            phase: i * 0.5
          };
          
          tails.push(tail);
          group.add(tail);
        }
        
        // Animate fox electricity
        function animateFox() {
          const time = Date.now() * 0.001;
          
          // Animate tails
          tails.forEach(tail => {
            const data = tail.userData;
            tail.rotation.y = Math.sin(time * data.waveFreq + data.phase) * data.waveAmp;
            tail.rotation.z = Math.cos(time * data.waveFreq + data.phase) * data.waveAmp;
          });
          
          // Animate eyes and pupils
          const blinkTime = Math.floor(time * 0.5) % 5;
          if (blinkTime === 4) {
            leftEye.scale.y = Math.max(0.1, Math.sin((time % 2) * Math.PI));
            rightEye.scale.y = Math.max(0.1, Math.sin((time % 2) * Math.PI));
            leftPupil.scale.y = Math.max(0.1, Math.sin((time % 2) * Math.PI));
            rightPupil.scale.y = Math.max(0.1, Math.sin((time % 2) * Math.PI));
          } else {
            leftEye.scale.y = 1;
            rightEye.scale.y = 1;
            leftPupil.scale.y = 1;
            rightPupil.scale.y = 1;
          }
          
          // Subtle head movement
          head.rotation.x = Math.sin(time * 0.5) * 0.1;
          head.rotation.y = Math.cos(time * 0.3) * 0.1;
          
          requestAnimationFrame(animateFox);
        }
        
        animateFox();
        
        return group;
      }
      
      function createHornSpiritCore() {
        const group = new THREE.Group();
        
        // Oni base
        const baseGeo = new THREE.SphereGeometry(0.4, 16, 16);
        const baseMat = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.8,
          emissive: color,
          emissiveIntensity: 0.4
        });
        
        const base = new THREE.Mesh(baseGeo, baseMat);
        group.add(base);
        
        // Horns
        const hornShape = new THREE.Shape();
        hornShape.moveTo(0, 0);
        hornShape.lineTo(0.1, 0);
        hornShape.lineTo(0.08, 0.5);
        hornShape.lineTo(0, 0.6);
        hornShape.lineTo(-0.08, 0.5);
        hornShape.lineTo(-0.1, 0);
        hornShape.lineTo(0, 0);
        
        const extrudeSettings = {
          steps: 1,
          depth: 0.1,
          bevelEnabled: true,
          bevelThickness: 0.02,
          bevelSize: 0.02,
          bevelSegments: 3
        };
        
        const hornGeo = new THREE.ExtrudeGeometry(hornShape, extrudeSettings);
        const hornMat = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.9,
          emissive: color,
          emissiveIntensity: 0.5
        });
        
        const leftHorn = new THREE.Mesh(hornGeo, hornMat);
        leftHorn.position.set(-0.2, 0.3, 0);
        leftHorn.rotation.z = -0.2;
        group.add(leftHorn);
        
        const rightHorn = new THREE.Mesh(hornGeo, hornMat);
        rightHorn.position.set(0.2, 0.3, 0);
        rightHorn.rotation.z = 0.2;
        group.add(rightHorn);
        
        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.8
        });
        
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.15, 0.1, 0.3);
        group.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.15, 0.1, 0.3);
        group.add(rightEye);
        
        // Glitch effects
        const glitchCount = 8;
        const glitches = [];
        
        for (let i = 0; i < glitchCount; i++) {
          const size = 0.05 + Math.random() * 0.1;
          const glitchGeo = new THREE.BoxGeometry(size, size, size);
          const glitchMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.7
          });
          
          const glitch = new THREE.Mesh(glitchGeo, glitchMat);
          glitch.position.set(
            (Math.random() - 0.5) * 0.8,
            (Math.random() - 0.5) * 0.8,
            (Math.random() - 0.5) * 0.8
          );
          
          glitch.userData = {
            originalPos: glitch.position.clone(),
            glitchSpeed: 0.5 + Math.random() * 2,
            glitchRange: 0.1 + Math.random() * 0.2
          };
          
          glitches.push(glitch);
          group.add(glitch);
        }
        
        // Animate oni glitches
        function animateOni() {
          const time = Date.now() * 0.001;
          
          // Pulse body
          base.scale.set(
            1 + Math.sin(time * 2) * 0.05,
            1 + Math.sin(time * 2) * 0.05,
            1 + Math.sin(time * 2) * 0.05
          );
          
          // Pulse eyes
          const eyePulse = 1 + Math.sin(time * 4) * 0.2;
          leftEye.scale.set(eyePulse, eyePulse, eyePulse);
          rightEye.scale.set(eyePulse, eyePulse, eyePulse);
          leftEye.material.opacity = 0.6 + Math.sin(time * 5) * 0.2;
          rightEye.material.opacity = 0.6 + Math.sin(time * 5) * 0.2;
          
          // Animate glitches
          glitches.forEach(glitch => {
            const data = glitch.userData;
            
            // Random "teleport" effect
            if (Math.random() > 0.99) {
              glitch.visible = false;
              setTimeout(() => {
                glitch.visible = true;
                glitch.position.set(
                  (Math.random() - 0.5) * 0.8,
                  (Math.random() - 0.5) * 0.8,
                  (Math.random() - 0.5) * 0.8
                );
                glitch.userData.originalPos = glitch.position.clone();
              }, Math.random() * 100);
            }
            
            // Oscillate position
            glitch.position.x = data.originalPos.x + Math.sin(time * data.glitchSpeed) * data.glitchRange;
            glitch.position.y = data.originalPos.y + Math.cos(time * data.glitchSpeed) * data.glitchRange;
            glitch.position.z = data.originalPos.z + Math.sin(time * data.glitchSpeed * 2) * data.glitchRange;
          });
          
          requestAnimationFrame(animateOni);
        }
        
        animateOni();
        
        return group;
      }
      
      function createRoundSpiritCore() {
        const group = new THREE.Group();
        
        // Tanuki body - round belly
        const bodyGeo = new THREE.SphereGeometry(0.45, 32, 32);
        const bodyMat = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.8,
          emissive: color,
          emissiveIntensity: 0.3
        });
        
        // Slightly flatten the sphere to make it more tanuki-like
        const positionAttr = bodyGeo.getAttribute('position');
        const vertex = new THREE.Vector3();
        
        for (let i = 0; i < positionAttr.count; i++) {
          vertex.fromBufferAttribute(positionAttr, i);
          vertex.y *= 0.85;
          positionAttr.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        
        bodyGeo.computeVertexNormals();
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        
        // Head
        const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
        const headMat = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.9,
          emissive: color,
          emissiveIntensity: 0.3
        });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.set(0, 0.2, 0.3);
        group.add(head);
        
        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.08, 0.25, 0.5);
        group.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.08, 0.25, 0.5);
        group.add(rightEye);
        
        // Ears
        const earGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const earMat = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.9,
          emissive: color,
          emissiveIntensity: 0.3
        });
        
        const leftEar = new THREE.Mesh(earGeo, earMat);
        leftEar.position.set(-0.15, 0.37, 0.33);
        group.add(leftEar);
        
        const rightEar = new THREE.Mesh(earGeo, earMat);
        rightEar.position.set(0.15, 0.37, 0.33);
        group.add(rightEar);
        
        // Tail
        const tailGroup = new THREE.Group();
        const tailSegments = 5;
        
        for (let i = 0; i < tailSegments; i++) {
          const tailGeo = new THREE.SphereGeometry(0.1 - i * 0.015, 8, 8);
          const tailMat = new THREE.MeshPhongMaterial({
            color: color,
            transparent: true,
            opacity: 0.8,
            emissive: color,
            emissiveIntensity: 0.3
          });
          
          const tailSegment = new THREE.Mesh(tailGeo, tailMat);
          tailSegment.position.z = -i * 0.08;
          tailGroup.add(tailSegment);
        }
        
        tailGroup.position.set(0, -0.1, -0.4);
        group.add(tailGroup);
        
        // Holographic transforming objects
        const transformObjects = [];
        const objectCount = 5;
        const objectShapes = ['box', 'sphere', 'cone', 'cylinder', 'torus'];
        
        for (let i = 0; i < objectCount; i++) {
          let obj;
          
          // Create random shape
          const shapeType = objectShapes[i % objectShapes.length];
          const objMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3,
            wireframe: true
          });
          
          switch(shapeType) {
            case 'box':
              obj = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.15), objMat);
              break;
            case 'sphere':
              obj = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), objMat);
              break;
            case 'cone':
              obj = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.2, 16), objMat);
              break;
            case 'cylinder':
              obj = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.15, 16), objMat);
              break;
            case 'torus':
              obj = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.03, 8, 16), objMat);
              break;
          }
          
          // Position in a circle around the tanuki
          const angle = (i / objectCount) * Math.PI * 2;
          obj.position.set(
            Math.cos(angle) * 0.6,
            0.3,
            Math.sin(angle) * 0.6
          );
          
          obj.userData = {
            originalPos: obj.position.clone(),
            rotationSpeed: 0.01 + Math.random() * 0.01,
            floatSpeed: 0.5 + Math.random() * 0.5,
            floatHeight: 0.05 + Math.random() * 0.05,
            transformPhase: i * Math.PI / objectCount,
            nextShapeIndex: (i + 1) % objectShapes.length,
            lastTransformTime: 0
          };
          
          transformObjects.push(obj);
          group.add(obj);
        }
        
        // Animate tanuki playfulness
        function animateTanuki() {
          const time = Date.now() * 0.001;
          
          // Bouncy body movement
          body.position.y = Math.sin(time * 2) * 0.05;
          
          // Head looks around
          head.rotation.y = Math.sin(time) * 0.3;
          
          // Tail wags
          tailGroup.rotation.x = Math.cos(time * 3) * 0.3;
          tailGroup.rotation.y = Math.sin(time * 2) * 0.5;
          
          // Animate transforming objects
          transformObjects.forEach(obj => {
            const data = obj.userData;
            
            // Rotate
            obj.rotation.x += data.rotationSpeed;
            obj.rotation.y += data.rotationSpeed * 1.5;
            
            // Float up and down
            obj.position.y = data.originalPos.y + Math.sin(time * data.floatSpeed) * data.floatHeight;
            
            // Occasionally transform shape
            if (time - data.lastTransformTime > 3 + Math.random() * 2) {
              data.lastTransformTime = time;
              
              // Create new shape
              const nextShape = objectShapes[data.nextShapeIndex];
              let newGeometry;
              
              switch(nextShape) {
                case 'box':
                  newGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                  break;
                case 'sphere':
                  newGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                  break;
                case 'cone':
                  newGeometry = new THREE.ConeGeometry(0.1, 0.2, 16);
                  break;
                case 'cylinder':
                  newGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.15, 16);
                  break;
                case 'torus':
                  newGeometry = new THREE.TorusGeometry(0.08, 0.03, 8, 16);
                  break;
              }
              
              obj.geometry.dispose();
              obj.geometry = newGeometry;
              
              // Update next shape index
              data.nextShapeIndex = (data.nextShapeIndex + 1) % objectShapes.length;
              
              // Flash when transforming
              obj.material.opacity = 0.7;
              setTimeout(() => {
                obj.material.opacity = 0.3;
              }, 200);
            }
          });
          
          requestAnimationFrame(animateTanuki);
        }
        
        animateTanuki();
        
        return group;
      }
      
      function createDefaultSpiritCore() {
        const geometry = new THREE.SphereGeometry(0.5, 32, 32);
        const material = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.7,
          emissive: color,
          emissiveIntensity: 0.5
        });
        
        return new THREE.Mesh(geometry, material);
      }
      
      function createSpiritParticles(config) {
        const particleCount = config.count;
        const particleGeo = new THREE.BufferGeometry();
        const particleMat = new THREE.PointsMaterial({
          color: color,
          size: config.size,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });
        
        const positions = new Float32Array(particleCount * 3);
        const velocities = [];
        
        // Initialize particle positions based on flow pattern
        switch(config.flowPattern) {
          case 'water':
            // Particles in flowing water pattern
            for (let i = 0; i < particleCount; i++) {
              const radius = 0.6 + Math.random() * 0.3;
              const theta = Math.random() * Math.PI * 2;
              const y = (Math.random() - 0.5) * 0.5;
              
              positions[i * 3] = radius * Math.cos(theta);
              positions[i * 3 + 1] = y;
              positions[i * 3 + 2] = radius * Math.sin(theta);
              
              velocities.push({
                speed: 0.02 + Math.random() * 0.02,
                direction: theta
              });
            }
            break;
            
          case 'wind':
            // Wind-like flow
            for (let i = 0; i < particleCount; i++) {
              const radius = 0.6 + Math.random() * 0.5;
              const theta = Math.random() * Math.PI * 2;
              const y = (Math.random() - 0.5) * 1.2;
              
              positions[i * 3] = radius * Math.cos(theta);
              positions[i * 3 + 1] = y;
              positions[i * 3 + 2] = radius * Math.sin(theta);
              
              velocities.push({
                speed: 0.03 + Math.random() * 0.03,
                direction: theta + Math.PI / 6 * (Math.random() - 0.5)
              });
            }
            break;
            
          case 'ghost':
            // Ghost-like vertical flow
            for (let i = 0; i < particleCount; i++) {
              const radius = 0.4 + Math.random() * 0.3;
              const theta = Math.random() * Math.PI * 2;
              const y = (Math.random() - 0.8) * 1.0;
              
              positions[i * 3] = radius * Math.cos(theta);
              positions[i * 3 + 1] = y;
              positions[i * 3 + 2] = radius * Math.sin(theta);
              
              velocities.push({
                speed: 0.01 + Math.random() * 0.01,
                direction: theta,
                rise: 0.005 + Math.random() * 0.01
              });
            }
            break;
            
          case 'electric':
            // Electric zapping pattern
            for (let i = 0; i < particleCount; i++) {
              const radius = 0.5 + Math.random() * 0.4;
              const theta = Math.random() * Math.PI * 2;
              const y = (Math.random() - 0.5) * 0.8;
              
              positions[i * 3] = radius * Math.cos(theta);
              positions[i * 3 + 1] = y;
              positions[i * 3 + 2] = radius * Math.sin(theta);
              
              velocities.push({
                speed: 0.03 + Math.random() * 0.04,
                direction: theta,
                zap: Math.random() > 0.7
              });
            }
            break;
            
          case 'glitch':
            // Glitchy erratic movement
            for (let i = 0; i < particleCount; i++) {
              const radius = 0.4 + Math.random() * 0.4;
              const theta = Math.random() * Math.PI * 2;
              const y = (Math.random() - 0.5) * 0.8;
              
              positions[i * 3] = radius * Math.cos(theta);
              positions[i * 3 + 1] = y;
              positions[i * 3 + 2] = radius * Math.sin(theta);
              
              velocities.push({
                speed: 0.01 + Math.random() * 0.02,
                direction: theta,
                glitchFactor: Math.random() * 0.1
              });
            }
            break;
            
          case 'playful':
            // Playful bouncing pattern
            for (let i = 0; i < particleCount; i++) {
              const radius = 0.5 + Math.random() * 0.5;
              const theta = Math.random() * Math.PI * 2;
              const y = (Math.random() - 0.5) * 0.8;
              
              positions[i * 3] = radius * Math.cos(theta);
              positions[i * 3 + 1] = y;
              positions[i * 3 + 2] = radius * Math.sin(theta);
              
              velocities.push({
                speed: 0.01 + Math.random() * 0.02,
                direction: theta,
                bounce: 0.5 + Math.random() * 1.5,
                phase: Math.random() * Math.PI * 2
              });
            }
            break;
            
          default:
            // Default circular pattern
            for (let i = 0; i < particleCount; i++) {
              const radius = 0.6 + Math.random() * 0.3;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              
              positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
              positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
              positions[i * 3 + 2] = radius * Math.cos(phi);
              
              velocities.push({
                speed: 0.01 + Math.random() * 0.01,
                direction: theta,
                inclination: phi
              });
            }
        }
        
        particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particles = new THREE.Points(particleGeo, particleMat);
        
        // Animation based on flow pattern
        function animateParticles() {
          const time = Date.now() * 0.001;
          const positions = particles.geometry.attributes.position.array;
          
          for (let i = 0; i < particleCount; i++) {
            const velocity = velocities[i];
            
            switch(config.flowPattern) {
              case 'water':
                // Flowing water movement
                velocity.direction += 0.01;
                positions[i * 3] = (0.6 + Math.sin(time + i) * 0.1) * Math.cos(velocity.direction);
                positions[i * 3 + 2] = (0.6 + Math.sin(time + i) * 0.1) * Math.sin(velocity.direction);
                break;
                
              case 'wind':
                // Windlike swirling
                velocity.direction += 0.02;
                const windRadius = 0.6 + Math.sin(time * 0.5 + i * 0.1) * 0.1;
                positions[i * 3] = windRadius * Math.cos(velocity.direction);
                positions[i * 3 + 1] += Math.sin(time * 2 + i) * 0.002;
                positions[i * 3 + 2] = windRadius * Math.sin(velocity.direction);
                break;
                
              case 'ghost':
                // Ghost-like rising
                positions[i * 3 + 1] += velocity.rise;
                if (positions[i * 3 + 1] > 0.8) {
                  positions[i * 3 + 1] = -0.8;
                  positions[i * 3] = (0.4 + Math.random() * 0.3) * Math.cos(Math.random() * Math.PI * 2);
                  positions[i * 3 + 2] = (0.4 + Math.random() * 0.3) * Math.sin(Math.random() * Math.PI * 2);
                }
                
                // Slight sideways drift
                positions[i * 3] += Math.sin(time * 2 + i) * 0.001;
                positions[i * 3 + 2] += Math.cos(time * 2 + i) * 0.001;
                break;
                
              case 'electric':
                // Electric zapping
                if (velocity.zap && Math.random() > 0.95) {
                  // Ocasional teleport
                  positions[i * 3] = (0.5 + Math.random() * 0.4) * Math.cos(Math.random() * Math.PI * 2);
                  positions[i * 3 + 1] = (Math.random() - 0.5) * 0.8;
                  positions[i * 3 + 2] = (0.5 + Math.random() * 0.4) * Math.sin(Math.random() * Math.PI * 2);
                } else {
                  // Normal movement with some jittering
                  velocity.direction += 0.03;
                  positions[i * 3] = (0.5 + Math.random() * 0.1) * Math.cos(velocity.direction);
                  positions[i * 3 + 1] += (Math.random() - 0.5) * 0.01;
                  positions[i * 3 + 2] = (0.5 + Math.random() * 0.1) * Math.sin(velocity.direction);
                }
                break;
                
              case 'glitch':
                // Glitchy movement
                if (Math.random() > 0.97) {
                  // Random teleports
                  positions[i * 3] = (0.4 + Math.random() * 0.4) * (Math.random() > 0.5 ? 1 : -1);
                  positions[i * 3 + 1] = (Math.random() - 0.5) * 0.8;
                  positions[i * 3 + 2] = (0.4 + Math.random() * 0.4) * (Math.random() > 0.5 ? 1 : -1);
                } else {
                  // Jittery movement
                  positions[i * 3] += (Math.random() - 0.5) * velocity.glitchFactor;
                  positions[i * 3 + 1] += (Math.random() - 0.5) * velocity.glitchFactor;
                  positions[i * 3 + 2] += (Math.random() - 0.5) * velocity.glitchFactor;
                  
                  // Keep within bounds
                  const dist = Math.sqrt(
                    positions[i * 3] * positions[i * 3] + 
                    positions[i * 3 + 2] * positions[i * 3 + 2]
                  );
                  
                  if (dist > 0.8) {
                    positions[i * 3] *= 0.8 / dist;
                                        positions[i * 3 + 2] *= 0.8 / dist;
                  }
                  
                  if (Math.abs(positions[i * 3 + 1]) > 0.8) {
                    positions[i * 3 + 1] *= 0.8 / Math.abs(positions[i * 3 + 1]);
                  }
                }
                break;
                
              case 'playful':
                // Playful bouncing pattern
                velocity.direction += 0.01;
                positions[i * 3] = (0.5 + Math.sin(time * velocity.bounce + velocity.phase) * 0.1) * Math.cos(velocity.direction);
                positions[i * 3 + 1] = Math.sin(time * velocity.bounce + velocity.phase) * 0.2;
                positions[i * 3 + 2] = (0.5 + Math.sin(time * velocity.bounce + velocity.phase) * 0.1) * Math.sin(velocity.direction);
                break;
                
              default:
                // Default circular pattern
                velocity.direction += velocity.speed;
                positions[i * 3] = 0.6 * Math.sin(velocity.inclination) * Math.cos(velocity.direction);
                positions[i * 3 + 1] = 0.6 * Math.sin(velocity.inclination) * Math.sin(velocity.direction);
                positions[i * 3 + 2] = 0.6 * Math.cos(velocity.inclination);
            }
          }
          
          particles.geometry.attributes.position.needsUpdate = true;
          requestAnimationFrame(animateParticles);
        }
        
        animateParticles();
        
        return particles;
      }
      
      function createSpiritAura(color, shape) {
        // Create a glowing aura around the spirit
        const auraGroup = new THREE.Group();
        
        // Create halo effect
        const haloGeo = new THREE.SphereGeometry(0.8, 32, 32);
        const haloMat = new THREE.ShaderMaterial({
          uniforms: {
            color: { value: new THREE.Color(color) },
            time: { value: 0 }
          },
          vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
              vNormal = normal;
              vPosition = position;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            uniform float time;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
              // Calculate fresnel for edge glow
              vec3 viewDir = normalize(cameraPosition - vPosition);
              float fresnel = 1.0 - max(0.0, dot(viewDir, vNormal));
              fresnel = pow(fresnel, 3.0) * 2.0;
              
              // Apply time-based pulsing
              float pulse = 0.5 + 0.5 * sin(time * 2.0);
              float opacity = mix(0.3, 0.5, pulse) * fresnel;
              
              gl_FragColor = vec4(color, opacity);
            }
          `,
          transparent: true,
          side: THREE.FrontSide,
          blending: THREE.AdditiveBlending
        });
        
        const halo = new THREE.Mesh(haloGeo, haloMat);
        auraGroup.add(halo);
        
        // Add some energy wisps based on spirit shape
        const wispCount = 12;
        const wisps = [];
        
        for (let i = 0; i < wispCount; i++) {
          const wispMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
          });
          
          // Create different wisp shapes based on spirit type
          let wisp;
          
          switch(shape) {
            case 'sphere': // Water
              // Water droplet shape
              const curve = new THREE.EllipseCurve(
                0, 0,
                0.1, 0.2,
                0, Math.PI * 2,
                false,
                0
              );
              
              const points = curve.getPoints(16);
              const wispGeo = new THREE.BufferGeometry().setFromPoints(points);
              wisp = new THREE.Line(wispGeo, wispMat);
              break;
              
            case 'wings': // Wind
              // Wind gust shape
              const wispGeo2 = new THREE.BufferGeometry();
              const wavePoints = [];
              
              for (let j = 0; j < 10; j++) {
                const x = j * 0.02 - 0.09;
                const y = Math.sin(j * 0.6) * 0.03;
                wavePoints.push(new THREE.Vector3(x, y, 0));
              }
              
              wispGeo2.setFromPoints(wavePoints);
              wisp = new THREE.Line(wispGeo2, wispMat);
              break;
              
            case 'wisp': // Ghost
              // Ghostly tendril
              const wispGeo3 = new THREE.BufferGeometry();
              const tendrils = [];
              
              for (let j = 0; j < 15; j++) {
                const y = -j * 0.01;
                const x = Math.sin(j * 0.5) * 0.02;
                tendrils.push(new THREE.Vector3(x, y, 0));
              }
              
              wispGeo3.setFromPoints(tendrils);
              wisp = new THREE.Line(wispGeo3, wispMat);
              break;
              
            case 'fox': // Electric
              // Lightning bolt
              const wispGeo4 = new THREE.BufferGeometry();
              const lightning = [];
              
              lightning.push(new THREE.Vector3(0, 0.1, 0));
              lightning.push(new THREE.Vector3(0.03, 0.05, 0));
              lightning.push(new THREE.Vector3(-0.02, 0, 0));
              lightning.push(new THREE.Vector3(0.04, -0.05, 0));
              lightning.push(new THREE.Vector3(0, -0.1, 0));
              
              wispGeo4.setFromPoints(lightning);
              wisp = new THREE.Line(wispGeo4, wispMat);
              break;
              
            case 'horns': // Glitch
              // Glitchy shard
              const wispGeo5 = new THREE.BufferGeometry();
              const shards = [];
              
              shards.push(new THREE.Vector3(0, 0.1, 0));
              shards.push(new THREE.Vector3(0.05, 0.02, 0));
              shards.push(new THREE.Vector3(0.02, -0.03, 0));
              shards.push(new THREE.Vector3(0.07, -0.08, 0));
              
              wispGeo5.setFromPoints(shards);
              wisp = new THREE.Line(wispGeo5, wispMat);
              break;
              
            case 'round': // Playful
              // Stars and playful shapes
              const wispGeo6 = new THREE.BufferGeometry();
              const stars = [];
              
              for (let j = 0; j < 5; j++) {
                const angle = (j / 5) * Math.PI * 2;
                const innerAngle = angle + Math.PI / 5;
                
                // Outer point
                stars.push(new THREE.Vector3(
                  Math.cos(angle) * 0.08,
                  Math.sin(angle) * 0.08,
                  0
                ));
                
                // Inner point
                stars.push(new THREE.Vector3(
                  Math.cos(innerAngle) * 0.03,
                  Math.sin(innerAngle) * 0.03,
                  0
                ));
              }
              
              stars.push(stars[0]); // Close the shape
              
              wispGeo6.setFromPoints(stars);
              wisp = new THREE.Line(wispGeo6, wispMat);
              break;
              
            default:
              // Simple circle
              const wispGeo7 = new THREE.BufferGeometry();
              const circle = [];
              
              for (let j = 0; j < 16; j++) {
                const angle = (j / 16) * Math.PI * 2;
                circle.push(new THREE.Vector3(
                  Math.cos(angle) * 0.05,
                  Math.sin(angle) * 0.05,
                  0
                ));
              }
              
              circle.push(circle[0]); // Close the circle
              
              wispGeo7.setFromPoints(circle);
              wisp = new THREE.Line(wispGeo7, wispMat);
          }
          
          // Position wisp randomly around the spirit
          const radius = 0.7 + Math.random() * 0.3;
          const angle = (i / wispCount) * Math.PI * 2;
          wisp.position.set(
            Math.cos(angle) * radius,
            (Math.random() - 0.5) * 0.5,
            Math.sin(angle) * radius
          );
          
          // Random rotation
          wisp.rotation.x = Math.random() * Math.PI * 2;
          wisp.rotation.y = Math.random() * Math.PI * 2;
          wisp.rotation.z = Math.random() * Math.PI * 2;
          
          wisp.userData = {
            radius: radius,
            angle: angle,
            speed: 0.1 + Math.random() * 0.2,
            pulseSpeed: 1 + Math.random() * 2
          };
          
          wisps.push(wisp);
          auraGroup.add(wisp);
        }
        
        // Animate aura
        const clock = new THREE.Clock();
        
        function animateAura() {
          const time = clock.getElapsedTime();
          
          // Update halo shader time
          if (halo.material.uniforms) {
            halo.material.uniforms.time.value = time;
          }
          
          // Animate wisps
          wisps.forEach(wisp => {
            const data = wisp.userData;
            data.angle += data.speed * 0.01;
            
            wisp.position.x = Math.cos(data.angle) * data.radius;
            wisp.position.z = Math.sin(data.angle) * data.radius;
            
            wisp.position.y += Math.sin(time * data.speed) * 0.001;
            wisp.material.opacity = 0.2 + Math.sin(time * data.pulseSpeed) * 0.1;
            
            wisp.rotation.y += 0.01;
          });
          
          requestAnimationFrame(animateAura);
        }
        
        animateAura();
        
        return auraGroup;
      }
      
      // Helper functions for creating detailed spirits
      
      function addKappaDetails(group, color) {
        // Add water plate on head
        const plateGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
        const plateMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.5
        });
        const plate = new THREE.Mesh(plateGeo, plateMat);
        plate.position.y = 0.3;
        group.add(plate);
        
        // Add water ripples on plate
        const rippleGeo = new THREE.CircleGeometry(0.15, 16);
        const rippleMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        const ripple = new THREE.Mesh(rippleGeo, rippleMat);
        ripple.position.y = 0.33;
        ripple.rotation.x = -Math.PI / 2;
        group.add(ripple);
        
        // Add data streams falling from plate
        const streamCount = 5;
        const streams = [];
        
        for (let i = 0; i < streamCount; i++) {
          const points = [];
          const segments = 8;
          const angle = (i / streamCount) * Math.PI * 2;
          const startX = Math.cos(angle) * 0.15;
          const startZ = Math.sin(angle) * 0.15;
          
          for (let j = 0; j < segments; j++) {
            const y = 0.3 - j * 0.1;
            const waveX = startX + Math.sin(j * 0.5) * 0.05;
            const waveZ = startZ + Math.cos(j * 0.5) * 0.05;
            points.push(new THREE.Vector3(waveX, y, waveZ));
          }
          
          const streamGeo = new THREE.BufferGeometry().setFromPoints(points);
          const streamMat = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.7
          });
          
          const stream = new THREE.Line(streamGeo, streamMat);
          stream.userData = {
            points: points.map(p => p.clone()),
            waveSpeed: 1 + Math.random() * 2
          };
          
          streams.push(stream);
          group.add(stream);
        }
        
        // Animate water streams
        function animateStreams() {
          const time = Date.now() * 0.001;
          
          streams.forEach(stream => {
            const points = stream.userData.points;
            const positions = stream.geometry.attributes.position.array;
            
            for (let i = 0; i < points.length; i++) {
              const basePoint = points[i];
              const waveX = Math.sin(time * stream.userData.waveSpeed + i * 0.5) * 0.03;
              const waveZ = Math.cos(time * stream.userData.waveSpeed + i * 0.5) * 0.03;
              
              positions[i * 3] = basePoint.x + waveX;
              positions[i * 3 + 1] = basePoint.y;
              positions[i * 3 + 2] = basePoint.z + waveZ;
            }
            
            stream.geometry.attributes.position.needsUpdate = true;
          });
          
          // Animate ripple
          ripple.scale.x = 1 + Math.sin(time * 2) * 0.1;
          ripple.scale.z = 1 + Math.sin(time * 2) * 0.1;
          ripple.material.opacity = 0.4 + Math.sin(time * 3) * 0.2;
          
          requestAnimationFrame(animateStreams);
        }
        
        animateStreams();
      }
      
      function addTenguDetails(group, color) {
        // Add mask
        const maskGeo = new THREE.SphereGeometry(0.25, 16, 16);
        const maskMat = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3
        });
        const mask = new THREE.Mesh(maskGeo, maskMat);
        mask.scale.z = 0.6;
        mask.position.z = 0.1;
        group.add(mask);
        
        // Add long nose
        const noseGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.4, 8);
        const noseMat = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3
        });
        const nose = new THREE.Mesh(noseGeo, noseMat);
        nose.rotation.x = Math.PI / 2;
        nose.position.z = 0.4;
        group.add(nose);
        
        // Add wind effects around
        const windCount = 8;
        const winds = [];
        
        for (let i = 0; i < windCount; i++) {
          const points = [];
          const angle = (i / windCount) * Math.PI * 2;
          const radius = 0.6 + Math.random() * 0.3;
          
          for (let j = 0; j < 20; j++) {
            const segmentAngle = angle + j * 0.1 * (Math.random() * 0.5 + 0.75);
            points.push(new THREE.Vector3(
              Math.cos(segmentAngle) * radius * (1 + Math.sin(j * 0.3) * 0.2),
              Math.sin(j * 0.5) * 0.2,
              Math.sin(segmentAngle) * radius * (1 + Math.sin(j * 0.3) * 0.2)
            ));
          }
          
          const windGeo = new THREE.BufferGeometry().setFromPoints(points);
          const windMat = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.4
          });
          
          const wind = new THREE.Line(windGeo, windMat);
          wind.userData = {
            speed: 0.2 + Math.random() * 0.3,
            originPoints: points.map(p => p.clone())
          };
          
          winds.push(wind);
          group.add(wind);
        }
        
        // Animate wind effects
        function animateWind() {
          const time = Date.now() * 0.001;
          
          winds.forEach(wind => {
            const speed = wind.userData.speed;
            const originPoints = wind.userData.originPoints;
            const positions = wind.geometry.attributes.position.array;
            
            for (let i = 0; i < originPoints.length; i++) {
              const origin = originPoints[i];
              const waveFactor = Math.sin(time * speed + i * 0.2) * 0.1;
              
              positions[i * 3] = origin.x * (1 + waveFactor);
              positions[i * 3 + 1] = origin.y + Math.sin(time * speed + i) * 0.05;
              positions[i * 3 + 2] = origin.z * (1 + waveFactor);
            }
            
            wind.geometry.attributes.position.needsUpdate = true;
          });
          
          requestAnimationFrame(animateWind);
        }
        
        animateWind();
      }
      
      function addYureiDetails(group, color) {
        // Add ghostly face
        const faceGeo = new THREE.SphereGeometry(0.25, 16, 16);
        const faceMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.8
        });
        const face = new THREE.Mesh(faceGeo, faceMat);
        face.position.y = 0.2;
        group.add(face);
        
        // Add ghostly trails
        const trailCount = 6;
        const trails = [];
        
        for (let i = 0; i < trailCount; i++) {
          const points = [];
          const segments = 15;
          const angle = ((i / trailCount) * Math.PI * 2) + Math.PI / 6;
          const xOffset = Math.cos(angle) * 0.2;
          const zOffset = Math.sin(angle) * 0.2;
          
          for (let j = 0; j < segments; j++) {
            const y = -j * 0.1;
            const waveX = Math.sin(j * 0.5) * 0.1;
            points.push(new THREE.Vector3(xOffset + waveX, y, zOffset));
          }
          
          const trailGeo = new THREE.BufferGeometry().setFromPoints(points);
          const trailMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.5 - i * 0.05
          });
          
          // Create a tube along the points
          const curve = new THREE.CatmullRomCurve3(points);
          const tubeGeo = new THREE.TubeGeometry(curve, segments, 0.05 - i * 0.005, 8, false);
          const trail = new THREE.Mesh(tubeGeo, trailMat);
          
          trail.userData = {
            basePoints: points.map(p => p.clone()),
            waveFreq: 1 + Math.random() * 2,
            waveAmp: 0.05 + Math.random() * 0.05
          };
          
          trails.push(trail);
          group.add(trail);
        }
        
        // Add ghostly eyes
        const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000066 });
        
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.1, 0.25, 0.15);
        group.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.1, 0.25, 0.15);
        group.add(rightEye);
        
        // Ghostly mouth
        const mouthGeo = new THREE.SphereGeometry(0.07, 8, 8);
        mouthGeo.scale(1, 0.5, 1);
        const mouthMat = new THREE.MeshBasicMaterial({ color: 0x000066 });
        const mouth = new THREE.Mesh(mouthGeo, mouthMat);
        mouth.position.set(0, 0.1, 0.15);
        group.add(mouth);
        
        // Animate ghost effects
        function animateGhost() {
          const time = Date.now() * 0.001;
          
          // Animate trails
          trails.forEach(trail => {
            const data = trail.userData;
            
            // Recreate tube with updated points
            const newPoints = [];
            for (let i = 0; i < data.basePoints.length; i++) {
              const base = data.basePoints[i];
              const waveX = Math.sin(time * data.waveFreq + i * 0.3) * data.waveAmp;
              const waveZ = Math.cos(time * data.waveFreq + i * 0.3) * data.waveAmp;
              
              newPoints.push(new THREE.Vector3(
                base.x + waveX,
                base.y,
                base.z + waveZ
              ));
            }
            
            const curve = new THREE.CatmullRomCurve3(newPoints);
            const newTubeGeo = new THREE.TubeGeometry(
              curve, data.basePoints.length, 0.05, 8, false
            );
            
            trail.geometry.dispose();
            trail.geometry = newTubeGeo;
          });
          
          // Animate face and eyes
          face.position.y = 0.2 + Math.sin(time * 0.7) * 0.05;
          leftEye.position.y = 0.25 + Math.sin(time * 0.7) * 0.05;
          rightEye.position.y = 0.25 + Math.sin(time * 0.7) * 0.05;
          mouth.position.y = 0.1 + Math.sin(time * 0.7) * 0.05;
          
          // Occasionally distort face for spooky effect
          if (Math.random() > 0.99) {
            face.scale.set(
              1 + (Math.random() - 0.5) * 0.2,
              1 + (Math.random() - 0.5) * 0.2,
              1 + (Math.random() - 0.5) * 0.2
            );
            
            setTimeout(() => {
              face.scale.set(1, 1, 1);
            }, 100 + Math.random() * 200);
          }
          
          requestAnimationFrame(animateGhost);
        }
        
        animateGhost();
      }
      
      function addKitsuneDetails(group, color) {
        // Add fox mask
        const headGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const headMat = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3
        });
        const head = new THREE.Mesh(headGeo, headMat);
        head.scale.z = 0.8;
        group.add(head);
        
        // Add fox ears
        const earGeo = new THREE.ConeGeometry(0.1, 0.2, 8);
        const earMat = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3
        });
        
        const leftEar = new THREE.Mesh(earGeo, earMat);
        leftEar.position.set(-0.15, 0.3, 0);
        leftEar.rotation.z = -0.3;
        group.add(leftEar);
        
        const rightEar = new THREE.Mesh(earGeo, earMat);
        rightEar.position.set(0.15, 0.3, 0);
        rightEar.rotation.z = 0.3;
        group.add(rightEar);
        
        // Add fox eyes
        const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ 
          color: 0xffaa00,
          emissive: 0xff6600,
          emissiveIntensity: 0.5
        });
        
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.1, 0.05, 0.2);
        group.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.1, 0.05, 0.2);
        group.add(rightEye);
        
        // Add multiple electric tails
        const tailCount = 9;
        const tails = [];
        
        for (let i = 0; i < tailCount; i++) {
          const points = [];
          const segments = 12;
          const angle = ((i / tailCount) * Math.PI / 2) - Math.PI / 4;
          
          for (let j = 0; j < segments; j++) {
            const x = Math.cos(angle) * (0.3 + j * 0.1);
            const y = Math.sin(j * 0.5) * 0.1;
            const z = Math.sin(angle) * (0.3 + j * 0.1) - j * 0.05;
            points.push(new THREE.Vector3(x, y, z));
          }
          
          const curve = new THREE.CatmullRomCurve3(points);
          const tailGeo = new THREE.TubeGeometry(curve, segments, 0.02, 8, false);
          const tailMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.6
          });
          
          const tail = new THREE.Mesh(tailGeo, tailMat);
          tail.userData = {
            points: points.map(p => p.clone()),
            waveSpeed: 2 + Math.random() * 3,
            waveAmplitude: 0.02 + Math.random() * 0.04
          };
          
          tails.push(tail);
          group.add(tail);
        }
        
        // Add electrical sparks
        const sparkCount = 20;
        const sparks = [];
        
        for (let i = 0; i < sparkCount; i++) {
          const sparkGeo = new THREE.SphereGeometry(0.02 + Math.random() * 0.03, 8, 8);
          const sparkMat = new THREE.MeshBasicMaterial({
            color: 0xffffaa,
            transparent: true,
            opacity: 0.7
          });
          
          const spark = new THREE.Mesh(sparkGeo, sparkMat);
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const radius = 0.5 + Math.random() * 0.3;
          
          spark.position.set(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
          );
          
          spark.userData = {
            originalPos: spark.position.clone(),
            speed: 0.1 + Math.random() * 0.2,
            lifetime: Math.random() * 2,
            age: Math.random() * 2,
            maxRadius: radius
          };
          
          sparks.push(spark);
          group.add(spark);
        }
        
        // Animate fox electricity
        function animateFox() {
          const time = Date.now() * 0.001;
          
          // Animate electric tails
          tails.forEach(tail => {
            const data = tail.userData;
            const newPoints = [];
            
            for (let i = 0; i < data.points.length; i++) {
              const base = data.points[i];
              const waveY = Math.sin(time * data.waveSpeed + i * 0.5) * data.waveAmplitude;
              
              newPoints.push(new THREE.Vector3(
                base.x,
                base.y + waveY,
                base.z
              ));
            }
            
            // Recreate geometry with new points
            const curve = new THREE.CatmullRomCurve3(newPoints);
            const newTailGeo = new THREE.TubeGeometry(curve, data.points.length, 0.02, 8, false);
            
            tail.geometry.dispose();
            tail.geometry = newTailGeo;
          });
          
          // Animate sparks
          sparks.forEach(spark => {
            const data = spark.userData;
            data.age += 0.016;
                        if (data.age > data.lifetime) {
              // Reset spark
              data.age = 0;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              const radius = 0.5 + Math.random() * 0.3;
              
              spark.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
              );
              
              data.originalPos = spark.position.clone();
              data.lifetime = Math.random() * 2;
            }
            
            // Electric movement
            if (Math.random() > 0.95) {
              // Random jump
              spark.position.x += (Math.random() - 0.5) * 0.1;
              spark.position.y += (Math.random() - 0.5) * 0.1;
              spark.position.z += (Math.random() - 0.5) * 0.1;
            }
            
            // Fade out as they age
            const lifeRatio = data.age / data.lifetime;
            spark.material.opacity = 0.7 * (1 - lifeRatio);
            
            // Ensure sparks don't get too far from fox
            const distFromCenter = spark.position.length();
            if (distFromCenter > data.maxRadius * 1.2) {
              const norm = data.maxRadius / distFromCenter;
              spark.position.multiplyScalar(norm);
            }
          });
          
          // Animate eyes
          const eyePulse = 1 + Math.sin(time * 4) * 0.2;
          leftEye.scale.set(eyePulse, eyePulse, eyePulse);
          rightEye.scale.set(eyePulse, eyePulse, eyePulse);
          
          requestAnimationFrame(animateFox);
        }
        
        animateFox();
      }
      
      function addOniDetails(group, color) {
        // Add horns
        const hornGeo = new THREE.ConeGeometry(0.08, 0.3, 8);
        const hornMat = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3
        });
        
        const leftHorn = new THREE.Mesh(hornGeo, hornMat);
        leftHorn.position.set(-0.2, 0.3, 0);
        leftHorn.rotation.z = -0.2;
        group.add(leftHorn);
        
        const rightHorn = new THREE.Mesh(hornGeo, hornMat);
        rightHorn.position.set(0.2, 0.3, 0);
        rightHorn.rotation.z = 0.2;
        group.add(rightHorn);
        
        // Add face
        const faceGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const faceMat = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.9,
          emissive: color,
          emissiveIntensity: 0.3
        });
        const face = new THREE.Mesh(faceGeo, faceMat);
        group.add(face);
        
        // Add glowing eyes
        const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ 
          color: 0xff0000,
          transparent: true,
          opacity: 0.8
        });
        
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.15, 0.05, 0.2);
        group.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.15, 0.05, 0.2);
        group.add(rightEye);
        
        // Add glitch cubes
        const glitchCount = 20;
        const glitches = [];
        
        for (let i = 0; i < glitchCount; i++) {
          const size = 0.05 + Math.random() * 0.1;
          const glitchGeo = new THREE.BoxGeometry(size, size, size);
          const glitchMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.5 + Math.random() * 0.3,
            wireframe: Math.random() > 0.7
          });
          
          const glitch = new THREE.Mesh(glitchGeo, glitchMat);
          glitch.position.set(
            (Math.random() - 0.5) * 1.2,
            (Math.random() - 0.5) * 1.2,
            (Math.random() - 0.5) * 1.2
          );
          
          glitch.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );
          
          glitch.userData = {
            originalPos: glitch.position.clone(),
            originalRot: glitch.rotation.clone(),
            glitchRate: 0.1 + Math.random() * 0.5,
            nextGlitch: Math.random() * 3
          };
          
          glitches.push(glitch);
          group.add(glitch);
        }
        
        // Create distortion effect shader
        const distortionGeo = new THREE.SphereGeometry(0.9, 32, 32);
        const distortionMat = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            color: { value: new THREE.Color(color) }
          },
          vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float time;
            
            void main() {
              vNormal = normal;
              
              // Add glitch displacement
              vec3 pos = position;
              float noise = sin(position.x * 10.0 + time) * sin(position.y * 8.0 + time) * sin(position.z * 12.0 + time) * 0.02;
              pos += normal * noise;
              
              vPosition = pos;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            uniform float time;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
              // Calculate fresnel for edge glow
              vec3 viewDir = normalize(cameraPosition - vPosition);
              float fresnel = 1.0 - max(0.0, dot(viewDir, vNormal));
              fresnel = pow(fresnel, 2.0);
              
              // Calculate noise for distortion pattern
              float noise = fract(sin(vPosition.x * 20.0 + time * 2.0) * 43758.5453123);
              
              // Create glitch stripes
              float stripes = step(0.8, fract(vPosition.y * 20.0 + time * 0.5));
              
              // Combine effects
              float alpha = max(fresnel * 0.3, stripes * 0.05) * smoothstep(0.6, 1.0, noise);
              
              gl_FragColor = vec4(color, alpha * 0.25);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide
        });
        
        const distortion = new THREE.Mesh(distortionGeo, distortionMat);
        group.add(distortion);
        
        // Animate oni effects
        function animateOni() {
          const time = Date.now() * 0.001;
          
          // Update distortion shader
          if (distortion.material.uniforms) {
            distortion.material.uniforms.time.value = time;
          }
          
          // Animate glitches
          glitches.forEach(glitch => {
            const data = glitch.userData;
            
            // Occasionally glitch position/rotation
            if (time > data.nextGlitch) {
              // Set next glitch time
              data.nextGlitch = time + data.glitchRate + Math.random();
              
              if (Math.random() > 0.5) {
                // Teleport glitch
                glitch.position.set(
                  (Math.random() - 0.5) * 1.2,
                  (Math.random() - 0.5) * 1.2,
                  (Math.random() - 0.5) * 1.2
                );
                
                data.originalPos = glitch.position.clone();
              } else {
                // Rotate glitch
                glitch.rotation.set(
                  Math.random() * Math.PI * 2,
                  Math.random() * Math.PI * 2,
                  Math.random() * Math.PI * 2
                );
                
                // Scale glitch
                const scale = 0.7 + Math.random() * 0.6;
                glitch.scale.set(scale, scale, scale);
                
                // Fade glitch
                glitch.material.opacity = 0.5 + Math.random() * 0.5;
              }
              
              // Occasionally change wireframe mode
              if (Math.random() > 0.8) {
                glitch.material.wireframe = !glitch.material.wireframe;
              }
            }
          });
          
          // Animate eyes
          leftEye.material.opacity = 0.7 + Math.sin(time * 5) * 0.3;
          rightEye.material.opacity = 0.7 + Math.sin(time * 5) * 0.3;
          
          // Occasionally create face distortion effect
          if (Math.random() > 0.97) {
            face.scale.set(
              1 + (Math.random() - 0.5) * 0.1,
              1 + (Math.random() - 0.5) * 0.1,
              1 + (Math.random() - 0.5) * 0.1
            );
            
            setTimeout(() => {
              face.scale.set(1, 1, 1);
            }, 100);
          }
          
          requestAnimationFrame(animateOni);
        }
        
        animateOni();
      }
      
      function addTanukiDetails(group, color) {
        // Add tanuki face
        const faceGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const faceMat = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3
        });
        const face = new THREE.Mesh(faceGeo, faceMat);
        face.scale.z = 0.8;
        group.add(face);
        
        // Add ears
        const earGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const earMat = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3
        });
        
        const leftEar = new THREE.Mesh(earGeo, earMat);
        leftEar.position.set(-0.2, 0.23, 0);
        group.add(leftEar);
        
        const rightEar = new THREE.Mesh(earGeo, earMat);
        rightEar.position.set(0.2, 0.23, 0);
        group.add(rightEar);
        
        // Add eyes
        const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.12, 0.05, 0.25);
        group.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.12, 0.05, 0.25);
        group.add(rightEye);
        
        // Add nose
        const noseGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const noseMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const nose = new THREE.Mesh(noseGeo, noseMat);
        nose.position.set(0, -0.05, 0.3);
        group.add(nose);
        
        // Add tail
        const tailGeo = new THREE.SphereGeometry(0.15, 16, 16);
        const tailMat = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3
        });
        const tail = new THREE.Mesh(tailGeo, tailMat);
        tail.position.set(0, -0.1, -0.35);
        group.add(tail);
        
        // Add holographic transformations
        const holoShapes = [];
        const shapes = ['cube', 'sphere', 'pyramid', 'torus', 'cylinder'];
        const shapeCount = 8;
        
        for (let i = 0; i < shapeCount; i++) {
          let shapeGeo;
          const shapeType = shapes[Math.floor(Math.random() * shapes.length)];
          
          // Create shape geometry
          switch(shapeType) {
            case 'cube':
              shapeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
              break;
            case 'sphere':
              shapeGeo = new THREE.SphereGeometry(0.1, 16, 16);
              break;
            case 'pyramid':
              shapeGeo = new THREE.ConeGeometry(0.12, 0.2, 4);
              break;
            case 'torus':
              shapeGeo = new THREE.TorusGeometry(0.08, 0.03, 16, 24);
              break;
            case 'cylinder':
              shapeGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.15, 16);
              break;
          }
          
          // Create holographic material
          const shapeMat = new THREE.MeshBasicMaterial({
            color: Math.random() > 0.5 ? color : 0xffffff,
            wireframe: true,
            transparent: true,
            opacity: 0.5
          });
          
          const shape = new THREE.Mesh(shapeGeo, shapeMat);
          
          // Position around the tanuki in a circle
          const angle = (i / shapeCount) * Math.PI * 2;
          const radius = 0.6;
          shape.position.set(
            radius * Math.cos(angle),
            0.1 + Math.random() * 0.3,
            radius * Math.sin(angle)
          );
          
          shape.userData = {
            floatSpeed: 0.5 + Math.random() * 1.0,
            rotationSpeed: 0.01 + Math.random() * 0.02,
            originalY: shape.position.y,
            floatHeight: 0.1 + Math.random() * 0.1,
            nextTransform: Math.random() * 5,
            angle: angle,
            radius: radius
          };
          
          holoShapes.push(shape);
          group.add(shape);
        }
        
        // Add playful trails
        const trailCount = 10;
        const trails = [];
        
        for (let i = 0; i < trailCount; i++) {
          const trailGeo = new THREE.BufferGeometry();
          const points = [];
          
          // Create curved path
          for (let j = 0; j < 20; j++) {
            const theta = j * 0.15;
            const radius = 0.4 + j * 0.03;
            
            points.push(new THREE.Vector3(
              Math.cos(theta) * radius,
              0.1 + j * 0.01,
              Math.sin(theta) * radius
            ));
          }
          
          trailGeo.setFromPoints(points);
          
          const trailMat = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.4
          });
          
          const trail = new THREE.Line(trailGeo, trailMat);
          trail.rotation.y = (i / trailCount) * Math.PI * 2;
          trail.userData = {
            rotateSpeed: 0.01 + Math.random() * 0.01,
            basePoints: points.map(p => p.clone())
          };
          
          trails.push(trail);
          group.add(trail);
        }
        
        // Animate tanuki playfulness
        function animateTanuki() {
          const time = Date.now() * 0.001;
          
          // Animate holographic shapes
          holoShapes.forEach(shape => {
            const data = shape.userData;
            
            // Floating movement
            shape.position.y = data.originalY + Math.sin(time * data.floatSpeed) * data.floatHeight;
            
            // Rotation
            shape.rotation.x += data.rotationSpeed;
            shape.rotation.y += data.rotationSpeed * 1.2;
            shape.rotation.z += data.rotationSpeed * 0.7;
            
            // Orbital movement
            const newAngle = data.angle + time * 0.1;
            shape.position.x = data.radius * Math.cos(newAngle);
            shape.position.z = data.radius * Math.sin(newAngle);
            
            // Occasionally transform
            if (time > data.nextTransform) {
              data.nextTransform = time + 3 + Math.random() * 3;
              
              // Choose a new shape
              const shapeType = shapes[Math.floor(Math.random() * shapes.length)];
              let newGeo;
              
              switch(shapeType) {
                case 'cube':
                  newGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                  break;
                case 'sphere':
                  newGeo = new THREE.SphereGeometry(0.1, 16, 16);
                  break;
                case 'pyramid':
                  newGeo = new THREE.ConeGeometry(0.12, 0.2, 4);
                  break;
                case 'torus':
                  newGeo = new THREE.TorusGeometry(0.08, 0.03, 16, 24);
                  break;
                case 'cylinder':
                  newGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.15, 16);
                  break;
              }
              
              // Replace geometry
              shape.geometry.dispose();
              shape.geometry = newGeo;
              
              // Flash when transforming
              shape.material.opacity = 1;
              setTimeout(() => {
                shape.material.opacity = 0.5;
              }, 200);
            }
          });
          
          // Animate trails
          trails.forEach(trail => {
            const data = trail.userData;
            
            // Rotate trail
            trail.rotation.y += data.rotateSpeed;
            
            // Undulate trail points
            const positions = trail.geometry.attributes.position.array;
            const basePoints = data.basePoints;
            
            for (let i = 0; i < basePoints.length; i++) {
              const base = basePoints[i];
              const undulate = Math.sin(time * 2 + i * 0.2) * 0.03;
              
              positions[i * 3] = base.x + undulate;
              positions[i * 3 + 1] = base.y + Math.sin(time * 3 + i * 0.3) * 0.02;
              positions[i * 3 + 2] = base.z + undulate;
            }
            
            trail.geometry.attributes.position.needsUpdate = true;
          });
          
          // Animate face and tail
          face.position.y = Math.sin(time * 2) * 0.05;
          leftEar.position.y = 0.23 + Math.sin(time * 2) * 0.05;
          rightEar.position.y = 0.23 + Math.sin(time * 2) * 0.05;
          leftEye.position.y = 0.05 + Math.sin(time * 2) * 0.05;
          rightEye.position.y = 0.05 + Math.sin(time * 2) * 0.05;
          nose.position.y = -0.05 + Math.sin(time * 2) * 0.05;
          
          // Wag tail
          tail.position.y = -0.1 + Math.sin(time * 2) * 0.05;
          tail.position.x = Math.sin(time * 5) * 0.1;
          
          requestAnimationFrame(animateTanuki);
        }
        
        animateTanuki();
      }
    }
    
    function createDetailedSpiritModel(type) {
      const group = new THREE.Group();
      
      // Choose color based on type
      let color, particleColor;
      switch(type) {
        case 'kappa':
          color = 0x00f3ff;
          particleColor = 0x00ffcc;
          break;
        case 'tengu':
          color = 0x00ffaa;
          particleColor = 0x00ff88;
          break;
        case 'yurei':
          color = 0xc0c0ff;
          particleColor = 0xaaaaff;
          break;
        case 'kitsune':
          color = 0xff6600;
          particleColor = 0xffaa00;
          break;
        case 'oni':
          color = 0xff0066;
          particleColor = 0xff0033;
          break;
        case 'tanuki':
          color = 0x66ff33;
          particleColor = 0x99ff66;
          break;
        default:
          color = 0x00f3ff;
          particleColor = 0x00ffcc;
      }
      
      // Create detailed model using correct functions per type
      switch(type) {
        case 'kappa':
          createDetailedKappa(group, color, particleColor);
          break;
        case 'tengu':
          createDetailedTengu(group, color, particleColor);
          break;
        case 'yurei':
          createDetailedYurei(group, color, particleColor);
          break;
        case 'kitsune':
          createDetailedKitsune(group, color, particleColor);
          break;
        case 'oni':
          createDetailedOni(group, color, particleColor);
          break;
        case 'tanuki':
          createDetailedTanuki(group, color, particleColor);
          break;
        default:
          createDefaultDetailedSpirit(group, color, particleColor);
      }
      
      return group;
      
      // Each detailed spirit creation function would be defined here...
      // For brevity, I'm omitting these as they would follow similar patterns
      // to the spirit models created above, but with more detail and complexity
      
      function createDetailedKappa(group, color, particleColor) {
        // Create a more detailed version of the kappa spirit
        // This would be similar to the kappa model above but more detailed
        
        // For example placeholder:
        const core = createSphereModel(color);
        core.scale.set(1.5, 1.5, 1.5);
        group.add(core);
      }
      
      function createDetailedTengu(group, color, particleColor) {
        // Create a more detailed version of the tengu spirit
        const core = createToriiModel();
        core.scale.set(1.5, 1.5, 1.5);
        group.add(core);
      }
      
      function createDetailedYurei(group, color, particleColor) {
        // Create a more detailed version of the yurei spirit
        const core = createSphereModel(color);
        core.scale.set(1.5, 1.5, 1.5);
        group.add(core);
      }
      
      function createDetailedKitsune(group, color, particleColor) {
        // Create a more detailed version of the kitsune spirit
        const core = createInterfaceModel();
        core.scale.set(1.5, 1.5, 1.5);
        group.add(core);
      }
      
      function createDetailedOni(group, color, particleColor) {
        // Create a more detailed version of the oni spirit
        const core = createCubeModel(color);
        core.scale.set(1.5, 1.5, 1.5);
        group.add(core);
      }
      
      function createDetailedTanuki(group, color, particleColor) {
        // Create a more detailed version of the tanuki spirit
        const core = createSphereModel(color);
        core.scale.set(1.5, 1.5, 1.5);
        group.add(core);
      }
      
      function createDefaultDetailedSpirit(group, color, particleColor) {
        // Create a generic detailed spirit
        const core = createSphereModel(color);
        core.scale.set(1.5, 1.5, 1.5);
        group.add(core);
      }
    }
    
    function animateSpirit(group, type) {
      // Base animation based on spirit type
      const clock = new THREE.Clock();
      
      function animate() {
        const time = clock.getElapsedTime();
        
        switch(type) {
          case 'kappa':
            // Water-like bobbing
            group.position.y = Math.sin(time * 1.5) * 0.1;
            break;
          case 'tengu':
            // Wind-like swaying
            group.rotation.z = Math.sin(time * 0.8) * 0.1;
            break;
          case 'yurei':
            // Ghostly floating
            group.position.y = Math.sin(time * 0.7) * 0.15;
            group.rotation.y = Math.sin(time * 0.3) * 0.2;
            break;
          case 'kitsune':
            // Quick, fox-like movements
            group.rotation.x = Math.sin(time * 1.2) * 0.05;
            group.position.x = Math.sin(time * 2) * 0.05;
            break;
          case 'oni':
            // Imposing presence with occasional glitches
            if (Math.random() > 0.99) {
              group.position.set(
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1
              );
              
              setTimeout(() => {
                group.position.set(0, 0, 0);
              }, 100);
            }
            break;
          case 'tanuki':
            // Playful bouncing
            group.position.y = Math.abs(Math.sin(time * 2)) * 0.1;
            group.rotation.z = Math.sin(time * 1.5) * 0.1;
            break;
          default:
            // Default gentle rotation
            group.rotation.y = time * 0.2;
        }
        
        requestAnimationFrame(animate);
      }
      
      animate();
    }
    
    // Sound System
    function initializeSoundscape() {
      // Create Howler sound objects
      const sounds = {
        ambient: new Howl({
          src: ['https://assets.codepen.io/123456/cyber_ambient.mp3'],
          loop: true,
          volume: 0.2,
          autoplay: false
        }),
        interface: new Howl({
          src: ['https://assets.codepen.io/123456/interface_click.mp3'],
          volume: 0.5,
          autoplay: false
        }),
        ritual: new Howl({
          src: ['https://assets.codepen.io/123456/ritual_ambient.mp3'],
          loop: true,
          volume: 0.4,
          autoplay: false
        }),
        activation: new Howl({
          src: ['https://assets.codepen.io/123456/activation.mp3'],
          volume: 0.6,
          autoplay: false
        }),
        complete: new Howl({
          src: ['https://assets.codepen.io/123456/ritual_complete.mp3'],
          volume: 0.7,
          autoplay: false
        })
      };
      
      // Expose sound player function globally
      window.playSound = function(id) {
        if (sounds[id]) {
          sounds[id].play();
        }
      };
      
      // Start ambient sound when user clicks enter button
      document.getElementById('enter-button').addEventListener('click', () => {
        sounds.ambient.play();
      });
    }
    
    // Toggle Terminal
    function toggleTerminal(show = true) {
      const terminal = document.getElementById('terminal');
      
      if (show) {
        terminal.style.bottom = '20px';
        setTimeout(() => {
          document.getElementById('terminal-input').focus();
        }, 500);
      } else {
        terminal.style.bottom = '-400px';
      }
      
      playSound('interface');
    }
    
    // Process Terminal Commands
    function processTerminalCommand(command) {
      const output = document.getElementById('terminal-output');
      const cmd = command.trim().toLowerCase();
      
      // Add command to output
      output.innerHTML += `<p>> ${command}</p>`;
      
      // Process command
      if (cmd === 'help') {
        output.innerHTML += `
          <p>Available commands:</p>
          <p>help - Display this help message</p>
          <p>clear - Clear the terminal</p>
          <p>status - Display system status</p>
          <p>scan - Scan for nearby spirits</p>
          <p>ritual - Begin spirit summoning ritual</p>
          <p>about - Display information about NEON PHANTASM</p>
        `;
      } else if (cmd === 'clear') {
        output.innerHTML = '';
      } else if (cmd === 'status') {
        output.innerHTML += `
          <p>SYSTEM: ONLINE</p>
          <p>SPIRITS DETECTED: ${Math.floor(Math.random() * 6)}</p>
          <p>NEXUS STABILITY: 87%</p>
          <p>ETHEREAL CONNECTION: ACTIVE</p>
          <p>DIGITAL SHRINE: ONLINE</p>
        `;
      } else if (cmd === 'scan') {
        output.innerHTML += `<p>Scanning for nearby spiritual entities...</p>`;
        setTimeout(() => {
          const spirits = ['Cyber Kappa', 'Neon Tengu', 'Digital Yūrei', 'Electric Kitsune', 'Glitch Oni', 'Hologram Tanuki'];
          const detected = spirits[Math.floor(Math.random() * spirits.length)];
          output.innerHTML += `<p>Scan complete. Detected: ${detected}</p>`;
          
          // Show scanner effect
          const scanner = document.getElementById('spirit-scanner');
          scanner.style.opacity = '1';
          setTimeout(() => {
            scanner.style.opacity = '0';
          }, 3000);
        }, 2000);
      } else if (cmd === 'ritual') {
        output.innerHTML += `<p>Initializing digital spirit summoning ritual...</p>`;
        setTimeout(() => {
          toggleRitual(true);
          output.innerHTML += `<p>Ritual interface activated.</p>`;
        }, 1000);
      } else if (cmd === 'about') {
        output.innerHTML += `
          <p>NEON PHANTASM v1.0.3</p>
          <p>A Cyber-Gothic Experience merging traditional yokai mythology with digital aesthetics.</p>
          <p>Created by Digital Spirits Research Initiative.</p>
        `;
      } else {
        output.innerHTML += `<p>Command not recognized. Type 'help' for available commands.</p>`;
      }
      
      // Scroll to bottom
      output.scrollTop = output.scrollHeight;
    }
    
    // Toggle Avatar System
    function toggleAvatarSystem(show = true) {
      const avatar = document.getElementById('avatar-system');
      
      if (show) {
        avatar.style.display = 'block';
      } else {
        avatar.style.display = 'none';
      }
      
      playSound('interface');
    }
    
    // Create User Avatar
    function createUserAvatar() {
      const name = document.getElementById('avatar-name').value || 'Anonymous Spirit';
      const type = document.getElementById('avatar-type').value;
      const affinity = document.getElementById('avatar-affinity').value;
      
      // Update HUD with user info
      const hudInfo = document.querySelector('.hud-info');
      hudInfo.innerHTML = `
        <p>USER: <span class="neon-text">${name}</span></p>
        <p>SPIRIT TYPE: <span class="neon-purple-text">${type}</span></p>
        <p>AFFINITY: <span class="neon-text">${affinity}</span></p>
      `;
      
      // Close avatar system
      toggleAvatarSystem(false);
      
      // Show confirmation
      const output = document.getElementById('terminal-output');
      output.innerHTML += `<p>Digital avatar created. Welcome, ${name}.</p>`;
      output.scrollTop = output.scrollHeight;
      
      playSound('activation');
    }
    
    // Show Spirit Info
    function showSpiritEntry(spirit) {
      const entry = document.getElementById(`spirit-${spirit}`);
      entry.style.display = 'block';
      playSound('interface');
    }
    
    // Hide Spirit Info
    function hideSpiritEntry(spirit) {
      const entry = document.getElementById(`spirit-${spirit}`);
      entry.style.display = 'none';
      playSound('interface');
    }

    // Toggle Ritual Interface
    function toggleRitual(show = true) {
      const ritual = document.getElementById('ritual-container');
      
      if (show) {
        ritual.style.display = 'block';
        setTimeout(() => {
          initializeRitual();
        }, 100);
        playSound('ritual');
      } else {
        ritual.style.display = 'none';
        playSound('interface');
        // Stop ritual sound
        Howler.stop('ritual');
      }
    }
    
    // Initialize Ritual
    function initializeRitual() {
      // Get elements
      const bg = document.querySelector('.ritual-bg');
      const title = document.querySelector('.ritual-title');
      const instructions = document.querySelector('.ritual-instructions');
      const circleContainer = document.querySelector('.ritual-circle-container');
      const outerRing = document.querySelector('.ritual-outer-ring');
      const outerRing2 = document.querySelector('.ritual-outer-ring-2');
      const outerRing3 = document.querySelector('.ritual-outer-ring-3');
      const symbolsContainer = document.querySelector('.ritual-symbols');
      const message = document.getElementById('ritual-message');
      const closeButton = document.getElementById('ritual-close');
      const cornerDecorations = document.querySelectorAll('.corner-decoration');
      
      // Reset any previous state
      const nodes = document.querySelectorAll('.ritual-node');
      nodes.forEach(node => {
        node.classList.remove('active');
      });
      
      // Clear any previous energy lines
      const energyLines = document.querySelector('.ritual-energy-lines');
      energyLines.innerHTML = '';
      
      // Reset ritual progress
      ritualProgress = {
        nodes: [],
        completed: false,
        currentStep: 0,
        sequence: generateSequence()
      };
      
      // Show elements with animations
      setTimeout(() => { bg.style.opacity = '1'; }, 200);
      setTimeout(() => { title.style.opacity = '1'; title.style.transform = 'translateY(0)'; }, 600);
      setTimeout(() => { instructions.style.opacity = '1'; instructions.style.transform = 'translateY(0)'; }, 800);
      setTimeout(() => { circleContainer.style.opacity = '1'; circleContainer.style.transform = 'scale(1)'; }, 1000);
      setTimeout(() => { outerRing.style.opacity = '0.6'; }, 1400);
      setTimeout(() => { outerRing2.style.opacity = '0.5'; }, 1600);
      setTimeout(() => { outerRing3.style.opacity = '0.4'; }, 1800);
      
      // Start animations for outer rings
      outerRing.style.animation = 'rotateClockwise 60s linear infinite';
      outerRing2.style.animation = 'rotateCounterClockwise 45s linear infinite';
      outerRing3.style.animation = 'rotateClockwise 30s linear infinite';
      
      // Show symbols around circle
      const symbols = document.querySelectorAll('.ritual-symbol');
      symbols.forEach((symbol, index) => {
        setTimeout(() => { symbol.style.opacity = '0.8'; }, 2000 + index * 100);
      });
      
      // Show message
      setTimeout(() => { message.style.opacity = '1'; message.style.transform = 'translateY(0)'; }, 2000);
      
      // Show corner decorations
      cornerDecorations.forEach(corner => {
        setTimeout(() => { corner.style.opacity = '0.6'; }, 2000);
      });
      
      // Show close button
      setTimeout(() => { closeButton.style.opacity = '1'; }, 2500);
      
      // Initialize the first ritual step hint
      setTimeout(() => {
        message.textContent = `Activate node ${ritualProgress.sequence[0]} to begin the ritual`;
        // Briefly highlight the first node
        const firstNode = document.querySelector(`.ritual-node[data-node="${ritualProgress.sequence[0]}"]`);
        firstNode.style.boxShadow = '0 0 30px rgba(0, 243, 255, 1)';
        setTimeout(() => {
          firstNode.style.boxShadow = '';
        }, 1500);
      }, 3000);
    }
    
    // Global ritual progress tracking
    let ritualProgress = {
      nodes: [],
      completed: false,
      currentStep: 0,
      sequence: []
    };
    
    // Generate a random ritual sequence
    function generateSequence() {
      const sequence = [];
      const available = [1, 2, 3, 4, 5, 6, 7, 8];
      
      // Pick 5 random unique nodes
      for (let i = 0; i < 5; i++) {
        const index = Math.floor(Math.random() * available.length);
        sequence.push(available[index]);
        available.splice(index, 1);
      }
      
      return sequence;
    }
    
    // Activate Ritual Node
    function activateRitualNode(node) {
      if (ritualProgress.completed) return;
      
      const nodeNumber = parseInt(node.getAttribute('data-node'));
      const message = document.getElementById('ritual-message');
      
      playSound('activation');
      
      // Check if it's the correct node in the sequence
      if (nodeNumber === ritualProgress.sequence[ritualProgress.currentStep]) {
        // Activate the node
        node.classList.add('active');
        ritualProgress.nodes.push(nodeNumber);
        ritualProgress.currentStep++;
        
        // Create energy connection to the ritual well
        createEnergyLine(node);
        
        // Check if the ritual is complete
        if (ritualProgress.currentStep >= ritualProgress.sequence.length) {
          completeRitual();
        } else {
          // Hint for the next node
          message.textContent = `Node ${nodeNumber} activated. Next, activate node ${ritualProgress.sequence[ritualProgress.currentStep]}`;
          
          // Briefly highlight the next node
          const nextNode = document.querySelector(`.ritual-node[data-node="${ritualProgress.sequence[ritualProgress.currentStep]}"]`);
          nextNode.style.boxShadow = '0 0 30px rgba(0, 243, 255, 1)';
          setTimeout(() => {
            nextNode.style.boxShadow = '';
          }, 1500);
          
          // Create some magical runes and particles
          createMagicalEffects(node.getBoundingClientRect());
        }
      } else {
        // Wrong node - reset sequence
        message.textContent = `Incorrect node activated. Ritual sequence reset.`;
        
        // Flash nodes red to indicate error
        document.querySelectorAll('.ritual-node.active').forEach(activeNode => {
          activeNode.style.borderColor = 'red';
          activeNode.style.boxShadow = '0 0 20px rgba(255, 0, 0, 0.7)';
          
          setTimeout(() => {
            activeNode.style.borderColor = '';
            activeNode.style.boxShadow = '';
            activeNode.classList.remove('active');
          }, 1000);
        });
        
        // Clear energy lines
        document.querySelector('.ritual-energy-lines').innerHTML = '';
        
        // Reset progress
        ritualProgress.nodes = [];
        ritualProgress.currentStep = 0;
        
        // Provide hint again after short delay
        setTimeout(() => {
          message.textContent = `Activate node ${ritualProgress.sequence[0]} to begin the ritual`;
          
          // Briefly highlight the first node again
          const firstNode = document.querySelector(`.ritual-node[data-node="${ritualProgress.sequence[0]}"]`);
          firstNode.style.boxShadow = '0 0 30px rgba(0, 243, 255, 1)';
          setTimeout(() => {
            firstNode.style.boxShadow = '';
          }, 1500);
        }, 2000);
      }
    }
    
    // Create energy line from node to ritual well
    function createEnergyLine(node) {
      const energyLines = document.querySelector('.ritual-energy-lines');
      const rect = node.getBoundingClientRect();
      const containerRect = document.querySelector('.ritual-circle-container').getBoundingClientRect();
      
      // Calculate positions relative to the container
      const nodeX = rect.left + rect.width/2 - containerRect.left;
      const nodeY = rect.top + rect.height/2 - containerRect.top;
      const centerX = containerRect.width/2;
      const centerY = containerRect.height/2;
      
      // Calculate angle and length
      const angle = Math.atan2(centerY - nodeY, centerX - nodeX);
      const length = Math.sqrt(Math.pow(centerX - nodeX, 2) + Math.pow(centerY - nodeY, 2));
      
      // Create energy line
      const line = document.createElement('div');
      line.className = 'energy-line';
      line.style.left = `${nodeX}px`;
      line.style.top = `${nodeY}px`;
      line.style.width = `${length}px`;
      line.style.transform = `rotate(${angle}rad)`;
      line.style.opacity = '0';
      
      energyLines.appendChild(line);
      
      // Animate the energy line
      setTimeout(() => {
        line.style.opacity = '1';
        
        // Fill liquid in well when line is complete
        setTimeout(() => {
          const liquid = document.querySelector('.ritual-liquid');
          const currentHeight = parseFloat(liquid.style.height || '0');
          const newHeight = currentHeight + 20; // 20% increase per node
          liquid.style.height = `${newHeight}%`;
        }, 500);
      }, 100);
    }
    
    // Create magical effects (runes and particles)
    function createMagicalEffects(nodeRect) {
      const container = document.querySelector('.ritual-particles');
      const containerRect = document.querySelector('.ritual-circle-container').getBoundingClientRect();
      
      // Create floating runes
      for (let i = 0; i < 3; i++) {
        const rune = document.createElement('div');
        rune.className = 'ritual-rune';
        
        // Pick random rune character
        const runeChars = ['᛫', '᛬', 'ᚠ', 'ᚢ', 'ᚦ', 'ᚨ', 'ᚱ', 'ᚲ', 'ᚷ', 'ᚹ'];
        rune.textContent = runeChars[Math.floor(Math.random() * runeChars.length)];
        
        // Position relative to activated node
        const startX = nodeRect.left + nodeRect.width/2 - containerRect.left;
        const startY = nodeRect.top + nodeRect.height/2 - containerRect.top;
        
        rune.style.left = `${startX}px`;
        rune.style.top = `${startY}px`;
        
        // Set random float animation
        const tx = (Math.random() - 0.5) * 100;
        const ty = (Math.random() - 0.5) * 100;
        rune.style.setProperty('--tx', `${tx}px`);
        rune.style.setProperty('--ty', `${ty}px`);
        
        container.appendChild(rune);
        
        // Animate
        setTimeout(() => {
          rune.style.animation = `floatRune 2s ease-out forwards`;
        }, i * 200);
        
        // Remove after animation completes
        setTimeout(() => {
          rune.remove();
        }, 2500 + i * 200);
      }
      
      // Create particles
      for (let i = 0; i < 10; i++) {
        const particle = document.createElement('div');
        particle.className = 'ritual-particle';
        
        // Position relative to activated node
        const startX = nodeRect.left + nodeRect.width/2 - containerRect.left;
        const startY = nodeRect.top + nodeRect.height/2 - containerRect.top;
        
        particle.style.left = `${startX}px`;
        particle.style.top = `${startY}px`;
        
        // Set random float animation
        const tx = (Math.random() - 0.5) * 150;
        const ty = (Math.random() - 0.5) * 150;
        particle.style.setProperty('--tx', `${tx}px`);
        particle.style.setProperty('--ty', `${ty}px`);
        
        container.appendChild(particle);
        
        // Animate
        setTimeout(() => {
          particle.style.animation = `floatParticle 1.5s ease-out forwards`;
        }, i * 50);
        
        // Remove after animation completes
        setTimeout(() => {
          particle.remove();
        }, 2000 + i * 50);
      }
    }
    
    // Complete the ritual
    function completeRitual() {
      const message = document.getElementById('ritual-message');
      message.textContent = "Ritual sequence complete. Summoning in progress...";
      
      playSound('complete');
      
      // Get elements
      const ritual = document.getElementById('ritual-container');
      const liquid = document.querySelector('.ritual-liquid');
      const portal = document.querySelector('.ritual-portal');
      const spirit = document.querySelector('.ritual-spirit');
      const well = document.querySelector('.ritual-well');
      const rays = document.querySelector('.ritual-rays');
      
      // Fill the well completely
      liquid.style.height = '100%';
      
      // Add ripple effect to liquid
      well.style.overflow = 'visible';
      well.style.transform = 'scale(1.05)';
      well.style.boxShadow = '0 0 50px var(--neon-cyan)';
      well.querySelector('::before').style.opacity = '1';
      
      // After liquid fills, show the portal
      setTimeout(() => {
        portal.style.width = '80%';
        portal.style.height = '80%';
        portal.style.opacity = '1';
        portal.style.transform = 'translate(-50%, -50%) scale(1)';
        portal.style.animation = 'portalPulse 2s infinite';
        
        // Add rays of light
        rays.style.opacity = '1';
        const rayElements = rays.querySelectorAll('.ritual-ray');
        rayElements.forEach((ray, index) => {
          const angle = (index / rayElements.length) * Math.PI * 2;
          ray.style.width = '300px';
          ray.style.transform = `rotate(${angle}rad)`;
          ray.style.opacity = '0.5';
        });
        
        // Update message
        message.textContent = "Portal stabilized. Spirit manifestation imminent...";
        
        // Manifest the spirit
        setTimeout(() => {
          // Show spirit manifestation flash
          spirit.style.width = '100%';
          spirit.style.height = '100%';
          spirit.style.opacity = '1';
          spirit.style.animation = 'spiritManifest 2s forwards';
          
          // Create summoning circle pulse
          const summonPulse = document.createElement('div');
          summonPulse.style.position = 'absolute';
          summonPulse.style.width = '100%';
          summonPulse.style.height = '100%';
          summonPulse.style.border = '2px solid white';
          summonPulse.style.borderRadius = '50%';
          summonPulse.style.top = '0';
          summonPulse.style.left = '0';
          summonPulse.style.animation = 'summon-pulse 2s forwards';
          well.appendChild(summonPulse);
          
          // Update message
          message.textContent = "Spirit successfully summoned! Connection established.";
          
          // Update spirit count in HUD
          const spiritCount = document.getElementById('spirit-count');
          const currentCount = parseInt(spiritCount.textContent.split('/')[0]) + 1;
          spiritCount.textContent = `${currentCount}/6`;
          
          // After spirit manifestation, reset for future rituals
          setTimeout(() => {
            ritualProgress.completed = true;
            message.textContent = "Ritual completed. You may close this interface or perform another summoning.";
            
            // Create a spirit collection notification
            const terminalOutput = document.getElementById('terminal-output');
            
            // Choose a random spirit
            const spirits = ['Cyber Kappa', 'Neon Tengu', 'Digital Yūrei', 'Electric Kitsune', 'Glitch Oni', 'Hologram Tanuki'];
            const summonedSpirit = spirits[Math.floor(Math.random() * spirits.length)];
            
            terminalOutput.innerHTML += `<p class="neon-text">SPIRIT SUMMONED: ${summonedSpirit}</p>`;
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
          }, 3000);
        }, 2000);
      }, 1000);
    }
  </script>
</body>
</html>